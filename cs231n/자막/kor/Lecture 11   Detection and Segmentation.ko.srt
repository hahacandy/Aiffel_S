0
00:00:00,000 --> 00:00:06,000
Translated by visionNoob, KNU
https://github.com/insurgent92/CS231N_17_KOR_SUB

1
00:00:08,691 --> 00:00:15,429
안녕하세요. 진행하도록 하겠습니다.
CS231N 11강입니다.

2
00:00:15,430 --> 00:00:23,258
오늘은 Detection과 Segmentation등 아주 재미있는
Compuver Vision task들을 소개해 드리겠습니다.

3
00:00:23,259 --> 00:00:25,590
수업에 앞서 공지사항을 전달해 드리겠습니다.

4
00:00:25,590 --> 00:00:31,358
지난 시간에는 수업 대신 중간고사가 있었습니다.

5
00:00:31,358 --> 00:00:42,269
하지만 아직은 시험에 관한 이야기들은
삼가해 주시기 바랍니다.

6
00:00:42,270 --> 00:00:48,517
아직 시험을 치루지 않은 학생들이 있습니다.

7
00:00:48,518 --> 00:00:53,668
중간고사 문제와 관련된 이야기들은
되도록이면 삼가해 주시기 바랍니다.

8
00:00:56,329 --> 00:01:02,920
월요일까지만 참아주세요. [웃음] 좋습니다.

9
00:01:02,921 --> 00:01:07,760
현재 중간고사 채점을 진행 중입니다. 최대한
빨리 결과를 알려드리도록 하겠습니다.

10
00:01:07,761 --> 00:01:14,078
그리고 과제 2도 채점 중입니다. 이번 주에 거의 완료된 상태입니다.
TA들이 아주 바쁩니다.

11
00:01:14,079 --> 00:01:18,479
그리고 모두들 프로젝트를 열심히 진행해 주시고 있습니다.

12
00:01:18,479 --> 00:01:26,969
그리고 대부분 중간고사를 마쳤으므로 화요일까지는
프로젝트 마일스톤을 제출해 주시기 바랍니다.

13
00:01:26,970 --> 00:01:31,650
일부 인원들이 프로젝트 계획서 제출 이후에 프로젝트를
변경하거나, 팀원이 변경된 경우가 있었습니다.

14
00:01:31,650 --> 00:01:39,676
이번에 제출하는 마일스톤에 남은 학기동안 진행할
사항들을 반드시 반영시켜 주시기 바랍니다.

15
00:01:39,677 --> 00:01:43,900
그리고 Piazza에 많은 분들이 과제2에 대한 문의를 남겨주셨습니다.

16
00:01:43,900 --> 00:01:50,188
과제3은 작년과 내용이 조금 변경되어
현재 열심히 작업 중에 있습니다.

17
00:01:50,189 --> 00:01:53,951
과제3은 아마도 오늘, 내일쯤 확인하실 수 있을 것입니다.

18
00:01:53,951 --> 00:02:01,550
과제 제출기한은 출제일로부터 2주이므로
너무 걱적하지 않으셔도 됩니다.

19
00:02:01,551 --> 00:02:09,079
과제3에는 아주 흥미 진진한 내용들이 담겨 있으니
기대해 주시기 바랍니다.

20
00:02:09,079 --> 00:02:13,340
그리고 지난 강의에 "Train Game" 에 대해
말씀드린 적이 있습니다.

21
00:02:13,340 --> 00:02:17,780
Train Game은 우리가 현재 Side Project로 진행중입니다.

22
00:02:17,780 --> 00:02:27,340
Train Game은 실제 문제를 가지고 하이퍼파라미터를 조정하면서
학습시켜 볼 수 있는 반응형 도구입니다.

23
00:02:27,340 --> 00:02:37,963
Train Game을 하는 것이 필수는 아니지만 참여자에 한해서
소량의 extra credit을 지급할 예정입니다.

24
00:02:37,963 --> 00:02:42,224
자세한 사항은 오후 중으로 Piazza에 다시 공지하겠습니다.

25
00:02:42,224 --> 00:02:51,752
Train Game이 무엇인지 간략한 Demo를 보여드리겠습니다.
실제 이름은 HyperQuest 입니다.

26
00:02:51,752 --> 00:02:54,464
모델에 가장 적합한 하이퍼파라미터를
찾는 게임이라서 붙혀진 이름입니다.

27
00:02:54,464 --> 00:03:01,254
HyperQuest은 브라우저 환경에서 하이퍼파라미터를
조절해가며 모델을 학습시킬 수 있는 아주 멋있는 툴입니다.

28
00:03:01,254 --> 00:03:04,871
우선 Student ID와 Name으로 로그인합니다.

29
00:03:04,871 --> 00:03:08,830
그리고 여러분의 딥러닝 지식에 관한
몇 가지 설문조사를 수행합니다.

30
00:03:08,830 --> 00:03:16,152
그리고 몇 가지 지시사항이 있습니다.
여러분은 매 시도마다 임의의 데이터를 부여받습니다.

31
00:03:16,152 --> 00:03:21,494
데이터셋은 이미지이거나 벡터일 수도 있습니다.
HyperQuest에서 여러분이 해야 할 일은

32
00:03:21,494 --> 00:03:28,077
적절한 하이퍼파라미터를 선택해서 모델을 학습시키고
Tran/Validation Set의 성능을 높히는 것입니다.

33
00:03:28,077 --> 00:03:33,423
Leaderboard도 제공됩니다.

34
00:03:33,423 --> 00:03:38,723
게임을 시작하면 여러분께 데이터셋에 관련된
간단한 통계들을 알려드립니다.

35
00:03:38,723 --> 00:03:42,397
가령 이 예제에서는 클래스 10개를 분류해야하는
Classification 문제입니다.

36
00:03:43,424 --> 00:03:47,774
아래 임의의 데이터셋에 대한 통계가 있습니다.
클래스는 10가지 이고

37
00:03:47,774 --> 00:03:52,987
그리고 입력 데이터는 3 x 32 x 32 이미지 데이터입니다.

38
00:03:52,987 --> 00:03:58,832
그리고 Train Set 8500개
Validation Set 1500 개가 있습니다.

39
00:03:58,832 --> 00:04:01,518
이들은 모두 임의로 결정되며
매번 조금씩 바뀝니다.

40
00:04:01,518 --> 00:04:08,931
이 통계정보를 바탕으로 Init Learning rate, 네트워크 사이즈,
Init Dropout rate를 결정하시면 됩니다.

41
00:04:08,931 --> 00:04:13,811
설정이 끝나면 이 화면을 보실 수 있습니다.
모델은 선택된 하이퍼파라미터로 1 epoch 학습이 진행됩니다.

42
00:04:13,811 --> 00:04:21,040
그리고 오른쪽 아래에 두 개의 그래프가 있습니다.
하나는 1 epoch 이후의 Train/Validation Loss 입니다.

43
00:04:21,040 --> 00:04:23,409
그리고 다른 하나는 Train/Validation Accuracy 입니다.

44
00:04:23,409 --> 00:04:32,290
이 그래프를 보시고 다음 Epoch의 하이퍼 파라미터를
적절하게 조절하시면 되겠습니다.

45
00:04:32,290 --> 00:04:37,803
분석이 끝나면 기존의 또는 변경된 하이퍼파라미터로
학습을 계속 진행시키거나

46
00:04:37,803 --> 00:04:43,872
학습을 끝내거나, 혹은 뭔가 잘못 되었을 시에
기존의 체크포인트로 돌아갈 수도 있습니다.

47
00:04:43,872 --> 00:04:54,971
학습을 계속한다면, 이런 식으로 다음 Epoch을 위해서
하이퍼파라미터를 새롭게 조정할 수 있습니다.

48
00:04:54,971 --> 00:05:01,899
그리고 흥미롭게도 학습 도중에도
네트워크의 크기를 조절할 수 있습니다.

49
00:05:01,899 --> 00:05:07,562
여기에는 최근 발표된 논문들의 기법들이 적용되었습니다.

50
00:05:07,562 --> 00:05:15,762
학습 도중에 네트워크의 기존 레이어들은 유지시키고
레이어를 넓히거나 새로운 레이어를 추가할 수 있습니다.

51
00:05:15,762 --> 00:05:20,131
이 방법을 이용해서 여러분도 학습 도중에
네트워크의 크기를 변경할 수 있습니다.

52
00:05:20,131 --> 00:05:33,072
학습이 끝나면 최종 Validation accuracy가 leaderboard
에 기록되며, baseline models과 비교해 보실 수 있습니다.

53
00:05:33,072 --> 00:05:39,774
HyperQuest에 참여하여 Leaderboard에 좋은 성능을 기록하시면
소량의 Extra credit을 드릴 예정입니다.

54
00:05:39,774 --> 00:05:42,322
다시한번 말씀드리지만 선택사항입니다.

55
00:05:42,322 --> 00:05:49,243
하지만 여러분에게는 하이퍼파라미터가 학습과정에 어떤 영향을
미치는지 알아볼 수 있는 아주 좋은 경험이 될 것입니다.

56
00:05:49,243 --> 00:05:54,872
이는 저희에게도 도움이 됩니다.
여러분이 실험이 참여하므로써 얻는 것들이 있습니다.

57
00:05:54,872 --> 00:06:04,422
저희는 사람들이 Neural Network를 학습시킬 때의 행동양상에
대한 관심이 많습니다. 여러분들의 결정이 도움이 될 것입니다.

58
00:06:04,422 --> 00:06:08,462
하지만 선택사항입니다.

59
00:06:08,462 --> 00:06:10,295
질문 있으십니까?
[학생이 질문]

60
00:06:15,080 --> 00:06:20,272
질문은 "이 실험이 논문으로 쓰여지는지" 입니다.

61
00:06:20,272 --> 00:06:29,510
희망사항입니다. 하지만 아직 실험의 초기단계라서
장담할 수는 없습니다. 그렇게 됐으면 좋겠군요

62
00:06:33,240 --> 00:06:35,000
[웃음]

63
00:06:35,000 --> 00:06:37,971
질문은 "학습 도중에 어떻게 레이어를 추가하는지"
입니다.

64
00:06:37,971 --> 00:06:45,291
지금 깊이있는 설명은 해드릴 수 없지만, 해당 논문은
Ian Goodfello가 저자로 들어간 Net2Net 이라는 논문입니다.

65
00:06:45,291 --> 00:06:48,240
또 하나는 Microsoft의 Network Morphism
이라는 논문입니다.

66
00:06:48,240 --> 00:06:52,407
이 두 논문을 보시면 어떻게 동작하는지
살펴보실 수 있을 것입니다.

67
00:06:53,680 --> 00:06:59,792
좋습니다. 이제 수업을 진행하겠습니다. 지난 시간에
Recurrent Neural Networks를 소개했습니다.

68
00:06:59,792 --> 00:07:03,032
RNN을 이용해서 다양한 문제를 시도해 볼 수 있었습니다.

69
00:07:03,032 --> 00:07:07,192
"one to one", "one to many", "many to one",
그리고 "many to many" 가 있었죠

70
00:07:07,192 --> 00:07:10,679
RNN은 Language modeling에 적용해 보았습니다.

71
00:07:10,679 --> 00:07:15,460
RNN으로 다양한 Character level Language model을
구축해서 다양한 시도를 해보았습니다.

72
00:07:15,460 --> 00:07:20,571
그리고 수학 수식, 셰익스피어, C 소스코드
등을 샘플링해 보았습니다.

73
00:07:20,571 --> 00:07:31,011
그리고 CNN feature extracter와 RNN Language
model 을 결합한 Image caption 문제도 살펴보았습니다.

74
00:07:31,011 --> 00:07:36,040
그리고 다양한 종류의 RNN을 살펴보았습니다.
Vanilla RNN이 있었죠

75
00:07:36,040 --> 00:07:42,331
Vanilla RNN은 문헌에 따라 Simple RNN 혹은
Elman RNN이라고도 합니다.

76
00:07:42,331 --> 00:07:44,997
그리고 LSTM도 배웠습니다.
Long Short Term Memory 입니다.

77
00:07:44,997 --> 00:07:59,443
수식은 복잡했지만, 이로인해 backprop 시 그레디언트를 더 잘
전달할 수 있었고 더 긴 시퀀스도 잘 학습할 수 있었습니다.

78
00:07:59,443 --> 00:08:03,982
오늘은 주제를 조금 바꿔보고자 합니다.
다양한 재미있는 Tasks를 소개해 드리고자합니다.

79
00:08:03,982 --> 00:08:08,992
지금까지는 image classification 문제를 위주로 다뤘습니다.

80
00:08:08,992 --> 00:08:13,262
오늘은 다양한 Computer Vision Tasks를 다뤄볼 예정입니다.

81
00:08:13,262 --> 00:08:21,942
Segmentation, Localization, Detection 등 다양한
Computer Vision Tasks와

82
00:08:21,942 --> 00:08:25,494
이 문제들을 CNN으로 어떻게 접근해 볼 수
있을지에 대해서 다룰 예정입니다.

83
00:08:25,494 --> 00:08:32,163
잠시 주제를 환기시켜 보겠습니다. 이 수업에서는 주로
Image Classification 문제를 다룹니다.

84
00:08:32,163 --> 00:08:36,583
입력 이미지가 들어오면 Deep Conv Net을 통과합니다.

85
00:08:36,583 --> 00:08:42,991
네트워크를 통과하면 Feature Vector가 나옵니다.
가령 AlexNet이나 VGG의 경우 4096 차원이었죠

86
00:08:42,991 --> 00:08:50,568
그리고 최종 Fully Connected Layer는
1000개의 클래스 스코어를 나타냅니다.

87
00:08:50,568 --> 00:08:55,660
이 예제에서는 1000개의 클래스는
ImageNet의 클래스를 의미하죠

88
00:08:55,660 --> 00:09:05,083
다시 말해, 입력 이미지가 들어오면
"전체 이미지"가 속하는 카테고리가 출력입니다.

89
00:09:05,083 --> 00:09:14,314
Image Classification은 아주 기본적인 Task입니다.
Deep Learning으로 더 흥미로운 것들이 가능할지 모릅니다.

90
00:09:14,314 --> 00:09:21,515
오늘은 그 흥미로운 것들 중 몇 가지를 다룰 것입니다.
이들이 Deep Learning으로 어떻게 동작하는지 살펴보겠습니다.

91
00:09:21,515 --> 00:09:28,852
더 자세히 들어가기 전에
요약 슬라이드를 먼저 살펴보겠습니다.

92
00:09:28,852 --> 00:09:31,480
우선 Semantic Segmentation에 대해 배울 것입니다.

93
00:09:31,480 --> 00:09:35,153
그리고 Classification + Localization 과
Object Detection에 대해서도 알아보겠습니다.

94
00:09:35,153 --> 00:09:39,086
그리고 Instance Segmentation도 간단하게 알아보겠습니다.

95
00:09:39,967 --> 00:09:44,035
우선 Sementic Segmentation 입니다.

96
00:09:44,035 --> 00:09:52,567
Sementic Segmentation 문제에서는 입력은 이미지이고
출력으로 이미지의 모든 픽셀에 카테고리를 정합니다.

97
00:09:52,567 --> 00:09:58,327
가령 이 예제의 경우는 입력이 고양이입니다.
아주 귀엽네요

98
00:09:58,327 --> 00:10:07,701
출력은 모든 픽셀에 대해서 그 픽셀이
"고양이, 잔디, 하늘, 나무, 배경"인지를 결정하는 것이죠

99
00:10:07,701 --> 00:10:11,922
Sementic Segmentation 에서도 Classification에서
처럼 카테고리가 있습니다.

100
00:10:11,922 --> 00:10:22,674
하지만 다른 점은 Classification 처럼 이미지 전체에
카테고리 하나가 아니라 모든 픽셀에 카테고리가 매겨집니다.

101
00:10:22,674 --> 00:10:27,340
semantic segmentation은 개별 객체를
구분하지 않습니다.

102
00:10:27,340 --> 00:10:31,523
가령 오른쪽 이미지를 보면 암소(Cow) 두 마리가 보입니다.

103
00:10:31,523 --> 00:10:39,741
Semantic Segmentation의 경우에는
픽셀의 카테고리만 구분해 줍니다.

104
00:10:39,741 --> 00:10:48,309
그렇기 때문에 암소 두마리를 구별할 수 없습니다.

105
00:10:48,309 --> 00:10:51,782
"암소" 라고 레이블링된 픽셀 덩어리만 얻을 수 있습니다.

106
00:10:51,782 --> 00:10:58,910
이는 Sementatic Segmentation의 단점입니다. 나중에 배울
Instance Segmentation이 이를 해결할 수 있습니다.

107
00:10:58,910 --> 00:11:02,882
우선 Semantoic Segmentation을 살펴보겠습니다.

108
00:11:04,437 --> 00:11:12,544
Semantic Segmentation 문제에 접근해볼 수 있는 방법
중 하나는 Classification을 통한 접근 입니다.

109
00:11:12,544 --> 00:11:17,755
Semantic Segmentation을 위해서
Sliding Window를 적용해볼 수 있습니다.

110
00:11:17,755 --> 00:11:27,763
입력 이미지를 아주 작은 단위로 쪼갭니다.

111
00:11:27,763 --> 00:11:31,310
이 예제에서는 암소의 머리 주변에서
영역 세 개를 추출했습니다.

112
00:11:31,310 --> 00:11:36,564
이제는 이 작은 영역만을 가지고 Classification 문제를
푼다고만 생각해 보겠습니다.

113
00:11:36,564 --> 00:11:41,246
해당 영역이 어떤 카테고리에 속하는지를 정하는 것이죠

114
00:11:41,246 --> 00:11:51,083
이미지 한장을 분류하기 위해서 만든 모델을 이용해서
이미지의 작은 영역을 분류하게 하게도 할 수 있을 것입니다.

115
00:11:51,083 --> 00:11:56,601
이 방법이 어느정도는 동작할 지 모르겠습니다만.
그렇게 좋은 방법은 아닙니다.

116
00:11:56,601 --> 00:12:02,498
왜냐하면 비용이 엄청나게 크기 떄문입니다.

117
00:12:02,498 --> 00:12:10,910
모든 픽셀에 대해서 작은 영역으로 쪼개고, 이 모든 영역을
forward/backward pass 하는 일은 상당히 비효율적입니다.

118
00:12:10,910 --> 00:12:25,509
그리고 서로 다른 영역이라도 인접해 있으면 어느정도는 겹쳐있기
때문에 특징들을 공유할 수도 있을 것입니다.

119
00:12:25,509 --> 00:12:37,194
이렇게 영역을 분할하는 경우에도 영역들 끼리
공유할만한 특징들이 아주 많을 것입니다.

120
00:12:37,194 --> 00:12:41,896
이렇게 개별적으로 적용하는 방법은 아주 나쁜 방법입니다.

121
00:12:41,896 --> 00:12:48,683
하지만 Semantic Segmentation을 하고자 할 때 가장
먼저 생각해 볼 수 있는 방법이라고 할 수 있습니다.

122
00:12:48,683 --> 00:12:53,372
이전 보다는 개선된 방법이 있습니다.
 Fully Convolutional Network 입니다.

123
00:12:53,372 --> 00:12:58,305
이미지 영역을 나누고 독집적으로 분류하는 방법이 아닙니다.

124
00:12:58,305 --> 00:13:06,501
FC-Layer가 없고 Convolution Layer 구성된
네트워크를 상상해 볼 수 있습니다.

125
00:13:06,501 --> 00:13:20,605
3 x 3 zero padding 을 수행하는 Conv Layer들을
쌓아올면 이미지의 공간정보를 손실하지 않을 것입니다.

126
00:13:20,605 --> 00:13:29,622
이 네트워크의 출력 Tensor는  C x H x W 입니다.
C는 카테고리의 수입니다.

127
00:13:29,622 --> 00:13:38,127
이 출력 Tensor는 입력 이미지의 모든 픽셀 값에 대해
Classification Scores를 매긴 값입니다.

128
00:13:38,127 --> 00:13:43,014
이는 Conv Layer만 쌓아올린 네트워크를
이용해서 계산할 수 있을 것입니다.

129
00:13:43,014 --> 00:13:50,558
이 네트워크를 학습시키려면 우선 모든 픽셀의 Classification
loss를 계산하고 평균 값을 취합니다.

130
00:13:50,558 --> 00:13:55,137
그리고 기존처럼 back propagation을 수행하면 됩니다.

131
00:13:55,137 --> 00:13:55,970
질문있나요?

132
00:13:58,430 --> 00:14:01,179
질문은 "Training data를 어떻게 만드는지" 입니다.

133
00:14:01,179 --> 00:14:06,899
아주 비용이 큰 작업입니다. 입력 이미지에 모든 필셀에
대해서 레이블링을 해야 합니다.

134
00:14:06,899 --> 00:14:14,613
사람들이 툴을 만들기도 합니다.
객체의 외관선만 그려주면 안을 채워넣는 식이죠

135
00:14:14,613 --> 00:14:17,604
하지만 일반적으로는 Train data를 만들거나 수집하는것은
비용이 상당이 큽니다.

136
00:14:29,243 --> 00:14:31,357
질문은 "손실 함수를 어떻게 디자인하는지" 입니다.

137
00:14:31,357 --> 00:14:39,025
이 문제에서는 모든 픽셀을 Classification하는 것입니다.
따라서 출력의 모든 픽셀에 Cross entropy를 적용합니다.

138
00:14:39,025 --> 00:14:42,212
출력의 모든 픽셀에는 Ground Truth가 존재합니다.

139
00:14:42,212 --> 00:14:48,143
출력의 모든 픽셀과 Ground Truth 간의
Cross Entropy를 계산합니다.

140
00:14:48,143 --> 00:14:52,739
이 값들을 모두 더하거나 평균화시켜서 Loss를 계산합니다.
또는 Mini-batch 단위로 계산할 수도 있습니다.

141
00:14:52,739 --> 00:14:53,572
질문있나요?

142
00:15:18,548 --> 00:15:28,008
질문은 "모든 픽셀의 카테고리를 알고 있다고
가정하는지" 입니다.

143
00:15:28,008 --> 00:15:31,258
맞습니다. 모든 픽셀의 카테고리를 알고
있다는 가정이 있어야합니다.

144
00:15:31,258 --> 00:15:33,716
Image Classification 의 경우와 마찬가지입니다.

145
00:15:33,716 --> 00:15:41,357
Image Classification의 경우에도 클래스의 수가
10, 20, 100, 1000이다 이렇게 딱 정해져 있었습니다.

146
00:15:41,357 --> 00:15:50,077
Semantic Segmentation에서도
클래스의 수가 고정되어 있습니다.

147
00:15:51,012 --> 00:16:00,562
이 모델은 하이퍼파라미터만 잘 조절해서 학습시켜주면
비교적 잘 동작합니다. 하지만 문제가 하나 있습니다.

148
00:16:00,562 --> 00:16:09,574
이 네트워크의 경우에는 입력 이미지의 Spatial Size를
계속 유지시켜야 합니다. 그래서 비용이 아주 큽니다.

149
00:16:09,574 --> 00:16:18,982
가령 Convolution의 채널이 64/128/256 일 수 있습니다.
이정도는 보통 네트워크게 아주 흔합니다.

150
00:16:18,982 --> 00:16:27,361
이 네트워크에 고해상도의 이미지가 입력으로 들어오면
게산량과 메모리가 엄청 커서 감당할 수 없을 것입니다.

151
00:16:27,361 --> 00:16:31,304
실제로는 이렇게 생긴 네트워크를 보기는 힘듭니다.

152
00:16:31,304 --> 00:16:40,592
대신에 이렇게 생긴 네트워크가 대부분입니다.
특징맵을 Downsampling/Upsampling 합니다.

153
00:16:40,592 --> 00:16:44,614
Spatial resolution 전체를 가지고
Convolution 수행하기 보다는

154
00:16:44,614 --> 00:16:48,997
Original Resolution 에서는
Conv layer는 소량만 사용합니다.

155
00:16:48,997 --> 00:16:55,719
그리고 Max pooling, Stride Convolution 등으로
특징맵을 Downsample 합니다.

156
00:16:55,719 --> 00:16:59,338
convolutions in downsampling
을 반복합니다.

157
00:16:59,338 --> 00:17:04,640
Classification Network와 구조가 유사해 보입니다.
하지만 차이점은

158
00:17:04,640 --> 00:17:15,213
Image Classification 에서는 FC-Layer가 있었죠. 하지만
여기에서는 Spatial Resolution을 다시 키웁니다.

159
00:17:15,214 --> 00:17:22,136
결국 다시 입력 이미지의 해상도와 같아집니다.
이 방법을 사용하면 계산 효율이 더 좋아집니다.

160
00:17:22,136 --> 00:17:29,749
이 방법을 통해 네트워크가 lower resolution을 처리하도록
하여 네트워크를 더 깊게 만들 수 있습니다.

161
00:17:29,749 --> 00:17:36,418
Convolutional Networks에서의
Downsampling에 대해서는 이미 본 적이 있으실 것입니다.

162
00:17:36,418 --> 00:17:44,050
이미지의 Spatial Size를 줄이기 위한 Stried Conv 라던가
다양한 Pooling 들은 다뤄본 적이 있었습니다.

163
00:17:44,050 --> 00:17:46,040
하지만 upsampling은 처음입니다.

164
00:17:46,040 --> 00:17:51,476
아마도 여러분은 upsampling이 네트워크 안에서
어떻게 동작하는지 궁금하실 수도 있습니다.

165
00:17:51,476 --> 00:17:55,875
네트워크의 특징맵의 사이즈를 키울 수 있는
전략이 무엇일까요?

166
00:17:55,875 --> 00:17:59,208
질문 있나요?

167
00:18:07,316 --> 00:18:09,061
질문은 "Upsampling을 어떻게 하는지" 입니다.

168
00:18:09,061 --> 00:18:11,758
이에 대한 답은
앞으로 진행할 내용입니다.

169
00:18:11,758 --> 00:18:13,263
[웃음]

170
00:18:13,263 --> 00:18:21,075
Upsampling 전량 중 하나는 unpooling 입니다.

171
00:18:21,075 --> 00:18:23,379
Downsample에서의 pooling에는 average/max
pooling 등이 있었습니다. average pooling은

172
00:18:23,379 --> 00:18:26,187
또는 우리가 평균 풀링에 대해 말했을 때 최대 풀링

173
00:18:26,187 --> 00:18:30,389
Pooling 하는 각 지역에 해당하는 Receptive Field 내에
spatial average를 계산했습니다.

174
00:18:30,389 --> 00:18:34,853
upsampling 방법 중에는
nearest neighbor unpooling이 있습니다.

175
00:18:34,853 --> 00:18:43,853
왼쪽에 nearest neighbor unpooling 예제가 있습니다.
입력은 2x2 그리드이고 출력은 4x4 그리드입니다.

176
00:18:43,853 --> 00:18:56,149
2x2 stride nearest neighbor unpooling은
해당하는 receptive field로 값을 그냥 복사합니다.

177
00:18:56,149 --> 00:19:03,472
bed of nails unpooling이란 방법도 있습니다.
bed of nails upsampling이라고도 합니다.

178
00:19:03,472 --> 00:19:09,116
이 방법은 unpooling region에만 값을 복사하고
다른 곳에는 모두 0을 채워넣습니다.

179
00:19:09,116 --> 00:19:23,462
이 경우 하나의 요소를 제외하고 모두 0으로 만듭니다. 이
예제에서는 왼쪽 위에만 값이 있고 나머지는 0입니다.

180
00:19:23,463 --> 00:19:24,867
"a  bed of nails" 이라고 불리는 이유는

181
00:19:24,867 --> 00:19:33,559
zero region은 평평하고 non-zero
region은 바늘처럼 뾰족하게 값이 튀기 때문입니다.

182
00:19:33,560 --> 00:19:39,591
Max unpooling이란 방법이 있습니다.

183
00:19:39,591 --> 00:19:52,046
대부분의 네트워크는 대칭적인 경향이 있습니다.
Downsampling/Upsampling 의 비율이 대칭적입니다.

184
00:19:52,047 --> 00:20:06,139
Max unpooling 이라는 방법이 있습니다. 각
unpooling과 pooling을 연관짓는 방법입니다.

185
00:20:06,140 --> 00:20:16,464
downsampling시에는 Max pooling에
사용했던 요소들을 잘 기억하고 있어야 합니다.

186
00:20:16,465 --> 00:20:26,390
Upsampling 시에 bed of nails
upsampling과 유사하되 같은 자리에 값을 넣는 것이 아니라

187
00:20:26,391 --> 00:20:33,697
이전 Maxpooling에서 선택된 위치에 맞게 넣어줍니다.

188
00:20:33,697 --> 00:20:38,321
제가 설명을 잘 했는지 모르겠네요.
백문이 불여일견이죠. 그림한번 보면 이해가 가실 것입니다.

189
00:20:39,248 --> 00:20:42,388
Maxunpooling이 끝나고 남은 자리를 0으로 채워줍니다.

190
00:20:42,388 --> 00:20:48,256
정리하자면,  Low Resolution 특징 맵을
 High Resolution 특징 맵으로 만들어 주는 것인데

191
00:20:48,256 --> 00:20:54,964
이 때 Low Resolution 의 값들을
Maxpooling에서 선택된 위치로 넣어주는 것입니다.

192
00:20:56,871 --> 00:21:00,723
아주 흥미로운 방법입니다.

193
00:21:00,723 --> 00:21:02,056
질문있나요?

194
00:21:08,696 --> 00:21:11,801
질문은 "왜 이 방법이 좋은 아이디어이고
어떤 점에서 중요한지" 입니다.

195
00:21:11,801 --> 00:21:16,806
Semantic segmentation 에서는 모든 픽셀들의
클래스를 모두 잘 분류해야 합니다.

196
00:21:16,806 --> 00:21:23,708
예측한 Segmentation 결과에서 객체들간의
디테일한 경계가 명확할수록 좋습니다.

197
00:21:23,708 --> 00:21:31,782
하지만 Maxpooling을 하게되면 특징맵의 비균진성이 발생합니다.
(2 x 2 pooling 에서 어디에서 왔는지 모름, 공간정보를 잃음)

198
00:21:31,782 --> 00:21:44,363
Maxpooling 후의 특징 맵만 봐서는 이 값들이
Receptive field 중 어디에서 왔는지 알 수 없습니다.

199
00:21:45,253 --> 00:21:53,759
Unpool 시에 기존 Maxpool 에서 뽑아온 자리로 값을 넣어주면
공간 정보를 조금은 더 디테일하게 다룰 수 있습니다.

200
00:21:53,759 --> 00:21:59,051
Max pooling 에서 읽어버린 공간정보를
조금은 더 잘 유지하도록 도와주는 것입니다.

201
00:21:59,051 --> 00:21:59,884
질문 있나요?

202
00:22:10,883 --> 00:22:13,809
질문은 "Maxunpooling이  Backprop을
더 수월하게 해주는지" 입니다.

203
00:22:13,809 --> 00:22:21,009
이 방법이 Backprob dynamics를 크게 바꾸지는 않습니다.
Maxpool indices를 저장하는 비용이 그렇게 크지 않습니다.

204
00:22:21,009 --> 00:22:24,851
다른 것들이 비하면 아주 작습니다.

205
00:22:24,851 --> 00:22:29,566
또 다른 방법이 있습니다.
Transpose Convolution 입니다.

206
00:22:29,566 --> 00:22:34,724
지금까지 살펴봤던 Unpooling 방법은 다시한번 말씀드리면

207
00:22:34,724 --> 00:22:38,945
Bed of nails, Nearest Neighbor,
Max unpooling 까지 다뤘습니다.

208
00:22:38,945 --> 00:22:44,964
이 방법은은 "고정된 함수" 이고
별도로 학습을 시키지는 않습니다.

209
00:22:44,964 --> 00:22:47,404
하지만 Strided convolution의 경우는 어떨까요?

210
00:22:47,404 --> 00:22:54,423
Strided convolution은 어떤 식으로 Downsampling을
해야할지를 네트워크가 학습할 수 있습니다.

211
00:22:54,423 --> 00:23:02,534
이와 유사하게 Upsampling에서도 학습가능한 방법이 있습니다.
바로 Transpose convolution 입니다.

212
00:23:02,534 --> 00:23:08,068
특징 맵을 Upsampling 할 때 어떤 방식으로
할 지를 학습할 수 있습니다.

213
00:23:08,068 --> 00:23:13,262
이 또한 특수한 방식의 Convolution의 일종입니다.

214
00:23:13,262 --> 00:23:16,663
일반적인 3 x 3 (stride = 1, padding =  1)
Convolution Filter가 동작하는 방식을 다시한번 살펴봅시다.

215
00:23:16,663 --> 00:23:20,488
이런 평범한 Convoltion은 우리 수업에서
수도없이 살펴봤습니다.

216
00:23:20,488 --> 00:23:24,316
입력은 4x4 입니다. 출력도 4x4죠.

217
00:23:24,316 --> 00:23:29,721
3x3 필터가 있고 이미지와 내적을 수행합니다.
우선 이미지의 좌 상단 구석부터 시작해 봅시다.

218
00:23:29,721 --> 00:23:35,409
내적의 결과는
출력(4x4)의 좌 상단 코너의 값이 됩니다.

219
00:23:35,409 --> 00:23:39,388
이 연산은 이미지 전체에 대해서 반복합니다.

220
00:23:39,388 --> 00:23:44,688
자 그럼 Strided convolution을 살펴보겠습니다.
Strided Convolution도 아주 유사합니다.

221
00:23:44,688 --> 00:23:49,648
다만 입력이 4x4 이고 출력은 2x2 입니다.

222
00:23:49,648 --> 00:24:00,808
계산 방식은 기존과 유사합니다. 3x3 필터가 있고
이미지의 좌상단 구석에서부터 내적을 계산합니다.

223
00:24:00,808 --> 00:24:08,879
하지만 Strided convolution은
한 픽셀씩 이동하면서 계산하지 않습니다.

224
00:24:08,879 --> 00:24:16,961
출력에서 한 픽셀 씩 움직이려면
입력에서는 두 픽셀 씩 움직여야 합니다.

225
00:24:16,961 --> 00:24:23,361
"Stride = 2" 는 입력/출력에서 움직이는 거리 사이의
비율이라고 해석할 수 있습니다.

226
00:24:23,361 --> 00:24:32,495
따라서 Stride = 2인 Strided convolution은
"학습 가능한 방법" 으로 2배 downsampling 하는 것을 의미합니다.

227
00:24:32,495 --> 00:24:42,638
Transpose convolution은 반대의 경우입니다.
입력이 2x2 이고 출력이 4x4 입니다.

228
00:24:42,638 --> 00:24:46,904
그리고 Transpose convolution을 위한 연산은
조금 다르게 생겼습니다.

229
00:24:46,904 --> 00:24:56,074
여기에서는 내적을 수행하지 않습니다.
우선 입력 특징맵에서 값을 하나 선택합니다.(빨간색)

230
00:24:56,074 --> 00:25:00,856
예제에서 처럼 좌상단에서 뽑은 이
하나의 값은 스칼라 값입니다.

231
00:25:00,856 --> 00:25:06,767
이 스칼라 값을 필터와 곱합니다. (3x3)
그리고 출력의 3x3 영역에 그 값을 넣습니다.

232
00:25:06,767 --> 00:25:14,428
Transpose convolution에서는 필터와 입력의
내적을 계산하는 것이 아니라

233
00:25:14,428 --> 00:25:24,911
입력 값이 필터에 곱해지는 가중치의 역할을 합니다.
출력 값은 필터 * 입력(가중치) 입니다.

234
00:25:24,911 --> 00:25:36,703
그리고 Upsampling 시에는 입력에서 한 칸씩 움직이는 동안
출력에서는 두 칸찍 움직입니다.

235
00:25:36,703 --> 00:25:43,713
왼쪽 입력의 파란색은 스칼라 값입니다.
이 값을 필터에 곱합니다.

236
00:25:43,713 --> 00:25:49,048
이렇게 가중치가 곱해진 필터 값을
출력 값에 넣어줍니다.

237
00:25:49,048 --> 00:25:54,765
출력에서는 Transpose convolution 간에
Receptive Field가 겹칠 수 있습니다.

238
00:25:54,765 --> 00:26:00,143
이렇게 겹치는 경우에는
간단하게 두 값을 더해줍니다.

239
00:26:00,143 --> 00:26:07,931
이 과정을 반복해서 끝마치면
학습 가능한 upsampling을 수행한 것입니다.

240
00:26:07,931 --> 00:26:14,466
Spatial size를 키워주기 위해서
학습된  필터 가중치를 이용한 것이죠

241
00:26:15,609 --> 00:26:19,975
그런데, 이 방법(transepose convolution) 은
문헌에 따라서 부르는 이름이 다양합니다.

242
00:26:19,975 --> 00:26:24,153
간혹 "deconvolution" 이라는 이름이 붙기도 합니다.

243
00:26:24,153 --> 00:26:27,024
하지만 그 이름은 그닥 좋지 않다고 생각합니다.

244
00:26:27,024 --> 00:26:34,066
신호처리의 관점에서 deconvolution은
Convolution 연산의 역 연산을 의미합니다.

245
00:26:34,066 --> 00:26:39,945
하지만 Transpose convolution은 그런 연산이 아닙니다.
그럼에도 불구하고 deconvolution라는 용어가 자주 보입니다.

246
00:26:39,945 --> 00:26:44,121
딥러닝 관련 논문에서 deconvolution이라는
용어는 주의해서 이해하셔야 합니다.

247
00:26:44,121 --> 00:26:48,280
그리고 간혹 upconvolution이라고 부르기도 합니다.
귀여운 이름이군요

248
00:26:48,280 --> 00:26:51,490
"fractionally strided convolution"
이라고도 합니다.

249
00:26:51,490 --> 00:27:01,437
stdie를 input/output간의 크기의 비율로 생각하면
이 예제는 stride 1/2 convolution 이라고 볼 수 있습니다.

250
00:27:01,437 --> 00:27:04,869
input : output = 1 : 2 이기 때문입니다.

251
00:27:04,869 --> 00:27:09,311
"backwards strided convolution" 라고도 부릅니다.

252
00:27:09,311 --> 00:27:15,287
왜냐하면 transpose conv의 forward pass를
수학적으로 계산해보면

253
00:27:15,287 --> 00:27:20,030
일반 Convolution의 backward pass와
수식이 동일하기 때문입니다.

254
00:27:20,030 --> 00:27:28,698
처음 그 용어를 접하면 생소할 수도 있지만,
그것이 사실이기 때문에 그 용어를 쓰기도 합니다.

255
00:27:28,698 --> 00:27:36,923
Transpose Convolution의 구체적인 예시를 살펴봅시다.
이해를 돕기위해서 1D Example을 가져왔습니다.

256
00:27:36,923 --> 00:27:41,272
이 예제에서는 1차원에서
3x3 Transpose Convolution을 수행합니다.

257
00:27:41,272 --> 00:27:46,091
죄송합니다. 3x3 이 아니라
3x1 transpose convolution 입니다.

258
00:27:46,091 --> 00:27:50,211
필터에는 세 개의 숫자가 있습니다. (x, y, z)
입력은 두 개의 숫자가 있습니다. (a, b)

259
00:27:50,211 --> 00:27:58,060
출력 값을 계산해봅시다. 입력이 가중치로 쓰이고 필터에
곱해집니다. 그리고 이 값을 출력에 넣습니다.

260
00:27:58,060 --> 00:28:03,597
그리고 Receptive field가 겹치는 부분은
그냥 더해줍니다.

261
00:28:03,597 --> 00:28:12,253
여러분은 왜 이 연산이 Transpose Conv라는 이름이 붙었는지
궁금하실 수 있습니다. 왜 이 이름이 적절한 이름일까요?

262
00:28:12,253 --> 00:28:15,530
이 이름의 유래는 Convolution 연산 자체를
해석해보면 알 수 있습니다.

263
00:28:15,530 --> 00:28:21,902
Convolution 연산은 언제든 행렬 곱 연산으로
나타낼 수 있습니다.

264
00:28:21,902 --> 00:28:25,737
이 예제에서도 쉬운 1차원 예제를 들어보겠습니다.

265
00:28:25,737 --> 00:28:33,470
Convolution 필터인 vector x는 3개의 원소를 가지고있습니다.

266
00:28:34,497 --> 00:28:38,706
그리고 입력 vector는 4개의 원소
A,B,C,D 를 가지고 있습니다.

267
00:28:38,706 --> 00:28:47,869
여기에서는 3x1 stride 1 convolution연산을 수행할
것입니다. 이 과정은 행렬곱으로 나타낼 수 있습니다.

268
00:28:47,869 --> 00:28:54,781
Convolution kernel x를
대문자 X 처럼 나타낼 수 있습니다.

269
00:28:54,781 --> 00:28:59,360
서로 다른 지역에 대해서 커널을 복사한 모양입니다.

270
00:28:59,360 --> 00:29:08,157
이렇게 만든 가중치 행렬 X를 가지고 Xa 연산을
수행하면 convolution과 결과가 동일합니다.

271
00:29:09,274 --> 00:29:17,770
Transpose Convolution은 같은 행렬을 사용해서 행렬곱
연산을 수행하되 이 행렬을 Transpose 시킵니다.

272
00:29:17,770 --> 00:29:26,491
왼쪽은 기존의 stride 1 convolution 이고
오른쪽은 stride 1 transpose convolution 입니다.

273
00:29:26,491 --> 00:29:31,018
조금 더 자세히 살펴보겠습니다.

274
00:29:31,018 --> 00:29:37,570
stride 1 transpose convolution의 모양을 보면
normal convolution과 유사하게 생겼습니다.

275
00:29:37,570 --> 00:29:42,334
border나 padding 같은 세부사항을 전부 고려하면
조금 다르겠지만 기본적으로 같은 연산입니다.

276
00:29:42,334 --> 00:29:45,879
하지만 stride = 2 인 경우에는 상황이 달라집니다.

277
00:29:45,879 --> 00:29:54,240
자 이제 왼쪽은 stride 2 convolution을
행렬곱 연산으로 표현한 것입니다.

278
00:29:54,240 --> 00:29:59,837
stride > 1 인 경우에는 transpose convolution
은 더이상 convolution이 아닙니다.

279
00:29:59,837 --> 00:30:04,985
왜 아닌지는 convolutions이 어떤 식으로
행렬 처럼 표현되는지 생각해보면 알 수 있습니다.

280
00:30:04,985 --> 00:30:13,913
이제 stride 2 transpose convolution은
normal convolution과 근본적으로 다른 연산이 됩니다.

281
00:30:13,913 --> 00:30:20,647
이것이 바로 Transpose Convolution 이라는 이름이
붙은 이유입니다. 상당히 좋은 이름이라고 생각합니다.

282
00:30:20,647 --> 00:30:22,980
질문있나요?

283
00:30:27,991 --> 00:30:29,646
[학생이 질문]

284
00:30:29,646 --> 00:30:36,523
슬라이드가 오타일 수도 있습니다.
Piazza에 올려주시면 수정하겠습니다.

285
00:30:36,523 --> 00:30:43,000
질문 있나요?

286
00:30:53,576 --> 00:30:56,360
질문은 "왜 평균을 내지 않고 합(sum)하는지" 입니다.

287
00:30:56,360 --> 00:31:03,404
그냥 더하기만 하는 이유는 앞서 살펴본
transpose convolution 수식 때문입니다.

288
00:31:03,404 --> 00:31:11,325
하지만 분명히 sum은 문제가 될 수 있습니다.
Receptive field의 크기에 따라서 magnitudes이 달라집니다.

289
00:31:11,325 --> 00:31:15,322
실제로 아주 최근들어 제기되고 있는 문제이기도 합니다.

290
00:31:15,322 --> 00:31:26,250
3x3 stride 2 transpose convolution을 사용하면
checkerboard artifacts가 발생하곤 합니다.

291
00:31:26,250 --> 00:31:37,127
최근 논문에서는 4x4 stride 2 혹은 2x2 stride 2
 사용하기도 합니다. 문제가 조금은 완화됩니다.

292
00:31:46,834 --> 00:31:52,515
질문은 "stride 1/2 convolution 이라는 용어는
어떻게 생겨났는지" 입니다.

293
00:31:52,515 --> 00:31:56,790
아마도 제 논문에서 나온 용어입니다.
사실은 그렇습니다 :D

294
00:31:56,790 --> 00:32:01,181
제가 논문을 쓸때 fractionally strided convolution
이라는 이름을 썼습니다.

295
00:32:01,181 --> 00:32:07,282
하지만 논문을 쓰고나서 다시한번 생각해보니
transpose convolution이 더 올바른 표현인 것 같습니다.

296
00:32:07,282 --> 00:32:13,746
이런 Semantic segmentation 구조는
상당히 일반적인 구조입니다.

297
00:32:13,746 --> 00:32:19,540
네트워크 내부에 downsampling/upsampling를 하는
거대한 convolution network가 있습니다.

298
00:32:19,540 --> 00:32:22,053
downsampling은
strided convolution이나 pooling을 사용하며

299
00:32:22,053 --> 00:32:28,035
upsampling은 transpose convolution 또는
다양한 종류의  unpooling or upsampling을 사용합니다.

300
00:32:28,035 --> 00:32:33,634
그리고 모든 픽셀에 대한 cross-entropy를 계산하면
네트워크 전체를 end-to-end로 학습시킬 수 있습니다.

301
00:32:33,634 --> 00:32:41,514
이 구조는 상당히 인상적입니다. Image classification에서
배웠던 많은 기법들이 녹아들어가 있습니다.

302
00:32:41,514 --> 00:32:45,414
이런 구조는 어떤 문제를 풀건
쉽게 확장시킬 수 있습니다. 대단한 구조입니다.

303
00:32:46,333 --> 00:32:52,024
다른 배울 Task는 "classification + localization"
입니다.

304
00:32:52,024 --> 00:32:54,953
image classification에 대해서는 수도없이 다뤘습니다.

305
00:32:54,953 --> 00:33:01,234
입력 이미지의 레이블을 매기는 문제였습니다. 하지만
때로는 더 많은 정보를 얻고 싶을 수 있습니다.

306
00:33:01,234 --> 00:33:09,077
이미지가 어떤 카테고리에 속하는지 뿐만 아니라
실제 객체가 어디에 있는지를 알 고 싶을 수 있습니다.

307
00:33:09,077 --> 00:33:17,874
이미지를 "Cat"에 분류하는 것 뿐만 아니라
이미지 내에 Cat이 어디에 있는지 네모박스를 그리는 것이죠

308
00:33:17,874 --> 00:33:22,713
classification plus localization 문제는
object detection 문제와는 구별됩니다.

309
00:33:22,713 --> 00:33:31,242
localization 문제에서는 이미지 내에서 내가 관심있는
객체가 오직 하나 뿐이라고 가정합니다.

310
00:33:31,242 --> 00:33:41,001
더 많은 객체를 찾고 싶을수도 있겠지만, 기본적으로 이미지 내에
객체 하나만 찾아서 레이블을 매기고 위치를 찾아냅니다.

311
00:33:41,001 --> 00:33:47,584
이 Task를 바로
classification plus localization라고 합니다.

312
00:33:47,584 --> 00:33:53,680
이 문제를 풀 때도 기존의 image classification에서
사용하던 기법들을 고스란히 녹일 수 있습니다.

313
00:33:53,680 --> 00:33:58,220
아키텍쳐의 기본 구조는 다음과 같습니다.

314
00:33:58,220 --> 00:34:09,301
력입력 이미지가 있고. 네트워크는 이 이미지를 입력으로합니다.
가령 이 예제에서는 AlexNet입니다. 그리고 출력이 있습니다.

315
00:34:09,301 --> 00:34:15,730
출력 레이어 직전의 FC-Layer는
"Class score"로 연결되서 카테고리를 결정합니다.

316
00:34:15,730 --> 00:34:21,109
하지만 여기에서는 FC-Layer가 하나 더 있습니다.
이는 4개의 원소를 가진 vector와 연결되어 있습니다.

317
00:34:21,109 --> 00:34:28,478
이 4개의 출력 값은 가령 width/height/x/y로
bounding box의 위치를 나타냅니다.

318
00:34:28,478 --> 00:34:34,228
이런 식으로 네트워크는 두 가지 출력값을 반환합니다.
하나는 Class Score입니다.

319
00:34:34,228 --> 00:34:39,094
다른 하나는 입력 영상 내의 객체 위치의
bounding box의 좌표입니다.

320
00:34:39,094 --> 00:34:44,489
이 네트워크를 학습시킬 때는
 loss가 두 개 존재합니다.

321
00:34:44,489 --> 00:34:47,210
그리고 이 문제는 fully supervised setting 을 가정합니다.

322
00:34:47,210 --> 00:34:55,330
따라서 학습 이미지에는 카테고리 레이블과
해당 객체의 bounding box GT를 동시에 가지고 있어야 합니다.

323
00:34:55,331 --> 00:34:57,118
자 이제 두 가지 Loss Function이 있습니다.

324
00:34:57,118 --> 00:35:03,360
우선 Class scores를 예측하기 위한
Softmax loss가 있습니다.

325
00:35:03,360 --> 00:35:13,669
그리고 Ground Truth Bbox와 예측한 Bbox 사이의
차이를 측정하는 Loss도 있습니다.

326
00:35:13,669 --> 00:35:20,509
L2 Loss로 BBox Loss를 가장 쉽게 디자인할 수 있습니다.

327
00:35:20,509 --> 00:35:27,728
또는 L1이나 smooth L1을 사용하셔도 됩니다.
조금은 달라지겠지만 기본적인 아이디어는 동일합니다.

328
00:35:27,728 --> 00:35:35,509
이 Loss들은 모두 예측한 Bbox와 GT Bbox 좌표
간의 차이에 대한 regression loss입니다.

329
00:35:35,509 --> 00:35:39,510
질문있나요?

330
00:35:49,410 --> 00:35:52,193
질문은 "왜 Classification과 Bbox Regression을
동시에 학습시키는 왜 좋으며,

331
00:35:52,193 --> 00:35:55,600
"가령 오분류에 대해서 Bbox가 있으면
어떻게 되는지" 입니다.

332
00:35:55,600 --> 00:35:59,901
일반적으로는 괜찮습니다.

333
00:35:59,901 --> 00:36:03,652
큰 문제가 되지 않습니다. 그리고 실제로 많은 사람들이
이 두 Loss를 동시에 학습시킵니다.

334
00:36:03,652 --> 00:36:09,592
두 Loss를 동시에 학습시켜도 됩니다. 하지만 가혹
오분류의 문제에서 까다로울 수도 있습니다.

335
00:36:09,592 --> 00:36:19,232
많이 쓰는 해결책 중 하나는  Bbox를  딱 하나만 예측하지 않고
Bbox를 카테고리마다 하나 씩 예측합니다.

336
00:36:19,232 --> 00:36:24,091
그리고 Ground Truth 카테고리에 속한
예측된 BBox에만 Loss와 연결시킵니다.

337
00:36:24,091 --> 00:36:28,318
사람들이 이런 방식을 많이 사용하며
실제로 아주 유용합니다.

338
00:36:28,318 --> 00:36:34,611
물론 이 설정은 아주 기본적인 설정이며 이것 만으로는
왁벽하지도 최적이지도 않을 수는 있습니다.

339
00:36:34,611 --> 00:36:37,361
질문 있나요?

340
00:36:41,226 --> 00:36:46,746
질문은 "두 개의 Loss의 단위가 달라서
Gradient 계산에 문제가 될 소지가 있지 않은지" 입니다.

341
00:36:46,746 --> 00:36:49,306
이 두 개의 Loss를 합친 Loss를
Multi-task Loss 라고 합니다.

342
00:36:49,306 --> 00:36:58,554
우선 그레디언트를 구하려면 네트워크 가중치들의
각각의 미분 값(scalar)을 계산해야 합니다.

343
00:36:58,554 --> 00:37:01,331
이제는 Loss가 두 개이니 미분 값(scalar)도 두 개 이고
이 두 개를 모두 최소화 시켜야 합니다.

344
00:37:01,331 --> 00:37:11,833
실제로는 두 Losses의 가중치를 조절하는 하이퍼파라이터가
있습니다. 두 Losses의 가중치 합이 최종 Loss입니다.

345
00:37:11,833 --> 00:37:15,642
그리고 이 두 Losses의 가중 합에 대한
그레디언트를 계산하는 것입니다.

346
00:37:15,642 --> 00:37:23,691
하지만 두 Losses 간의 가중치를 결정하는 것은 상당히 까다롭습니다.
이 가중치는 하이퍼파라미터로써 우리가 설정해 줘야만 합니다.

347
00:37:23,691 --> 00:37:27,851
이 하이퍼파라미터는 지금까지 우리가
살펴본 하이퍼파라미터들 보다는 상당히 다릅니다.

348
00:37:27,851 --> 00:37:32,390
이 하이퍼파라미터는 실제로
손실함수의 값 자체를 바꿔버리기 떄문입니다.

349
00:37:32,390 --> 00:37:43,091
지금까지는 하이퍼파라미터를 다양하게 조절하면서
 Loss가 어떻게 변하는 지를 관찰하였습니다.

350
00:37:43,091 --> 00:37:51,089
하지만 이 경우에는 하이퍼파라미터의 값이 변하면
Loss자체의 속성이 변하므로 비교하기가 상당히 까다롭습니다.

351
00:37:51,089 --> 00:37:54,473
따라서 이 하이퍼파라미터를 조절하는 것은
상당히 어렵습니다.

352
00:37:54,473 --> 00:38:00,393
따라서 이 하이퍼파라미터를 설정하는 적절한 방법은 여러분의
문제에 따라 케바케일 수 있습니다. 다만 일반적인 방법은

353
00:38:00,393 --> 00:38:08,163
Loss 값으로 비교할게 아니라
다른 성능 지표를 도입하는 것입니다.

354
00:38:08,163 --> 00:38:17,763
Cross Validation으로 하이퍼파라미터를 최적화 할 때
Loss가 아니라 실제 모델의 성능지표를 봐야 할 것입니다.

355
00:38:17,763 --> 00:38:18,596
질문있나요?

356
00:38:27,529 --> 00:38:32,682
질문은 "왜 굳이 학습을 한번에 시키는지
그냥 나눠서 하면 안되는지" 입니다.

357
00:38:38,131 --> 00:38:45,413
질문은 "앞 쪽의 큰 네트워크는 고정시키고
각 FC-layer만 학습시키는 방법은 어떤지" 입니다.

358
00:38:45,413 --> 00:38:52,702
사람들이 그렇게 하곤 합니다. 여러분이 이런 문제를
풀어야 할 때 시도해볼 만한 방법입니다.

359
00:38:52,702 --> 00:39:00,574
Transfer learning의 관점에서 보면 fine tune을
하면 항상 성능이 더 좋아집니다.

360
00:39:00,574 --> 00:39:09,280
ImageNet으로 학습시킨 모델을 가지고 여러분의 데이터셋에
작용한다면 적절한 Fine tune이 성능이 도움이 될 것입니다.

361
00:39:09,280 --> 00:39:16,870
실제로 사람들이 많이 하는 트릭 중 하나는 우선
네트워크를 Freeze하고 두  FC-layer를 학습시킵니다.

362
00:39:16,870 --> 00:39:20,398
그리고 두 FC-Layer가 수렴하면 다시
합쳐서 전체 시스템을 Fine-tune 하는 것입니다.

363
00:39:20,398 --> 00:39:24,558
실제로 사람들이 많이 하는 기법입니다.

364
00:39:24,558 --> 00:39:30,978
지난 시간에 ImageNet을 예로 들어서
Pre-Trained network를 소개해 드린 적 있었습니다.

365
00:39:31,979 --> 00:39:37,339
지 문제들은 잠시 재쳐두고. Bbox와 같이 이미지 내의
어떤 위치를 예측한다는 아이디어는

366
00:39:37,339 --> 00:39:41,881
classification plus localization 문제 이외에도
아주 다양한 문제에도 적용해 볼 수 있습니다.

367
00:39:41,881 --> 00:39:44,710
그 중 하나는 human pose estimation 입니다.

368
00:39:44,710 --> 00:39:49,440
human pose estimation 문제 에서는
사람 이미지가 입력으로 들어갑니다.

369
00:39:49,440 --> 00:39:56,462
출력은 이 사람의 각 관절의 위치입니다.
이 네트워크는 사람의 포즈를 예측합니다.

370
00:39:56,462 --> 00:39:59,030
이 사람의 팔다리가 어디에 있는지를 예측하는 것이죠

371
00:39:59,030 --> 00:40:04,060
일반적으로 대부분은 사람들의 관절의 수는 같습니다.
아주 심플한 가정입니다.

372
00:40:04,060 --> 00:40:06,862
모든 사람들이 그런 것은 아니겠지만
이 네트워크의 가정은 그렇습니다.

373
00:40:06,862 --> 00:40:15,430
이런 문제를 풀기 위해서는 가령 일부 Data sets은
14개의 관절의 위치로 사람의 포즈를 정의합니다.

374
00:40:10,251 --> 00:40:15,430


375
00:40:15,430 --> 00:40:23,150
사람의 발, 무릎, 엉덩이와 같이 말이죠.
이 네트워크의 입력은 사람 이미지입니다.

376
00:40:16,932 --> 00:40:23,150


377
00:40:23,150 --> 00:40:30,521
그리고 네트워크의 출력은 각 관절에 해당하는
14개의 좌표 값입니다.

378
00:40:27,132 --> 00:40:30,521


379
00:40:30,521 --> 00:40:40,619
예측된 14개의 점에 대해서 regression loss를
계산하고 backprop으로 학습시킵니다.

380
00:40:33,120 --> 00:40:40,619


381
00:40:40,619 --> 00:40:46,571
가장 심플하게 L2 loss를 사용하기도 하고
또는 다양한 regression losses를 적용할 수 있습니다.

382
00:40:43,579 --> 00:40:46,571


383
00:40:46,571 --> 00:40:47,404
질문있나요?

384
00:40:50,934 --> 00:40:53,992
질문은 "Regression Loss" 가 무엇인지 입니다.

385
00:40:52,432 --> 00:40:53,992


386
00:40:53,992 --> 00:40:57,294
"Regression Loss" 는 cross entropy나
softmax가 아닌 Losses를 의미합니다.

387
00:40:56,099 --> 00:40:57,294


388
00:40:57,294 --> 00:41:04,494
Regression Loss에는 가령 L2, L1,
smooth L1 loss 등이 있습니다.

389
00:40:59,094 --> 00:41:04,494


390
00:41:04,494 --> 00:41:10,502
Classification 과 Regression의 일반적인 차이점은
결과가 categorical 인지 continuous인지 입니다.

391
00:41:07,512 --> 00:41:10,502


392
00:41:10,502 --> 00:41:17,243
가령 고정된 갯수의 카테고리가 있고 모델을 이를
결정하기 위한 클래스 스코어를 출력하는 경우라면

393
00:41:12,643 --> 00:41:17,243


394
00:41:17,243 --> 00:41:25,022
지난 강의에서 배웠던 Cross entropy / softmax/ SVM
margin Loss와 같은 것들을 사용할 수 있을 것입니다.

395
00:41:19,942 --> 00:41:25,022


396
00:41:25,022 --> 00:41:30,222
반면 출력이 연속적인 값(continuous value) 인 경우라면,
가령 Pose estimation의 경우에는 관절의 위치입니다.

397
00:41:28,272 --> 00:41:30,222


398
00:41:30,222 --> 00:41:34,734
이런 경우에는 출력이 연속적인 값이기 때문에
다른 종류의 losses를 사용해야 합니다.

399
00:41:32,174 --> 00:41:34,734


400
00:41:34,734 --> 00:41:37,883
L2, L1 과 같은 Losses를 사용합니다.

401
00:41:37,883 --> 00:41:41,482
미리 확실한 설명을 해드리지 못한 점 죄송합니다.

402
00:41:41,482 --> 00:41:44,471
그러나 여기서 더 큰 요점은 언제든지

403
00:41:44,471 --> 00:41:46,832
고정 된 번호를 만들고 싶다는 것을 알고 있습니다.

404
00:41:46,832 --> 00:41:51,003
예를 들어 알고 있다면 네트워크 출력을

405
00:41:51,003 --> 00:41:58,763
가령 입력 이미지 안에 개와 고양이가 한마리씩
항상 존재한다는 사실을 이미 알고 있고,

406
00:41:54,344 --> 00:41:58,763


407
00:41:58,763 --> 00:42:05,304
개, 고양이에 대해서 Bbox를 그리는 문제라면
출력해야 하는 Bbox의 갯수는 항상 고정되어 있습니다.

408
00:42:01,392 --> 00:42:05,304


409
00:42:05,304 --> 00:42:10,743
이런 classification +   localization 문제를 풀기
위해서 Regression 개념을 도입하는 것입니다.

410
00:42:07,093 --> 00:42:10,743


411
00:42:10,743 --> 00:42:17,039
Regression output이 고정된 숫자(ex 16관절) 의 경우라면
pose estimation과 같은 다양한 문제를 풀 수 있습니다.

412
00:42:13,094 --> 00:42:17,039


413
00:42:19,062 --> 00:42:23,531
다음은 object detection 입니다.

414
00:42:23,531 --> 00:42:25,342
object detection은 논 할 거리가 정말 많은 (meaty)
주제입니다.

415
00:42:25,342 --> 00:42:27,422
 computer vision에서 가장 중요한 문제 중 하나입니다.

416
00:42:27,422 --> 00:42:33,902
Object Detection의 역사와 다양한 테크닉에 대해서만
하루종일 세미나를 진행할 수 있을 정도로 방대합니다.

417
00:42:29,910 --> 00:42:33,902


418
00:42:33,902 --> 00:42:42,582
이번 시간에는 Object Detection  + Deep Learning 에
관련한 주요 아이디어만 간단하게 짚고 넘어가겠습니다.

419
00:42:35,931 --> 00:42:42,582


420
00:42:42,582 --> 00:42:47,942
우선 Object Detection 문제에서도
고정된 카테고리가 있습니다.

421
00:42:44,731 --> 00:42:47,942


422
00:42:47,942 --> 00:42:55,321
가령 고양이, 개, 물고기 등 고정된 카테고리 갯수만 생각합니다.

423
00:42:52,182 --> 00:42:55,321


424
00:42:55,321 --> 00:42:59,030
Object Detection의 task는 입력 이미지가 주어지면

425
00:42:59,030 --> 00:43:05,641
이미지에 나타나는 객체들의 Bbox와 해당하는
카테고리를 예측합니다.

426
00:43:02,470 --> 00:43:05,641


427
00:43:05,641 --> 00:43:10,902
classification plus localization와는 조금 다릅니다.

428
00:43:08,710 --> 00:43:10,902


429
00:43:10,902 --> 00:43:15,302
왜냐하면 예측해야 하는 Bbox의 수가
입력 이미지에 따라 달라지기 떄문입니다.

430
00:43:13,620 --> 00:43:15,302


431
00:43:15,302 --> 00:43:22,870
각 이미지에 객체가 몇 개나 있을지가 미지수입니다.
꽤나 어려운 문제입니다.

432
00:43:17,910 --> 00:43:22,870


433
00:43:22,870 --> 00:43:31,870
해마다 Image Classification의 성능이 얼마나
상승했는지를 보여주는 그래프를 살펴본 적이 있었죠

434
00:43:25,630 --> 00:43:31,870


435
00:43:31,870 --> 00:43:34,761
매년 성능이 점점 향상되었습니다.

436
00:43:34,761 --> 00:43:37,342
object detection에서도 유사한 트랜드를 보입니다.

437
00:43:37,342 --> 00:43:44,110
Object Detection은 Computer Vision에서 중요한
문제이기 때문에 사람들이 오래 전부터 연구하던 분야입니다.

438
00:43:39,131 --> 00:43:44,110


439
00:43:44,110 --> 00:43:48,742
이 그래프는 Object Detection 분야를 오랫동안 연구해온
 Ross Girshick의 슬라이드에서 가져왔습니다.

440
00:43:46,390 --> 00:43:48,742


441
00:43:48,742 --> 00:43:59,462
PASCAL VOC Dataset에서의 성능의 진보과정을 보여줍니다.
PASCAL VOC은 Detection 에서 아주 오래전부터 사용되었습니다.

442
00:43:51,070 --> 00:43:59,462


443
00:43:59,462 --> 00:44:08,161
2012년 까지 Object Detection의 성능은 점점 정체 되었습니다.

444
00:44:02,428 --> 00:44:08,161


445
00:44:08,161 --> 00:44:16,171
하지만 2013년 Deep Learning 이 도입된 이후로는
매년 성능이 아주 빠르게 증가했습니다.

446
00:44:10,039 --> 00:44:16,171


447
00:44:16,171 --> 00:44:21,422
한 가지 주목할 만한 점은 2015년에 그래프가 끝납니다.
물론 그 이후로도 성능은 계속 올라갔을 것입니다.

448
00:44:21,422 --> 00:44:29,928
State of the art의 성능은 80%를 훌쩍 넘을 것입니다.
하지만 더 이상 논하지 않습니다. 이제는 너무 쉽기 때문이죠

449
00:44:29,929 --> 00:44:37,421
State of the art의 성능을 정확히 알진
못하지만 이 그래프의 최정상에 위치할 것입니다.

450
00:44:37,422 --> 00:44:40,924
질문있나요?
괜찮습니다.

451
00:44:42,051 --> 00:44:50,960
Object Detection이 Localization과는
다르게 객체의 수가 이미지마다 다릅니다.

452
00:44:50,961 --> 00:44:57,770
가령 좌상단의 고양이 이미지는 객체가 하나 뿐입니다.
따라서 네트워크는 4개의 숫자만 예측하면 됩니다.

453
00:44:57,771 --> 00:45:05,551
그 다음은 객체가 3개 입니다. 각 Bbox마다
좌표 4개 씩 도합 12개의 값을 예측해야 합니다.

454
00:45:05,552 --> 00:45:13,210
마지막 오리 사진의 경우에는 오리 한 마리 당 값이
4 개씩 아주 많은 값을 예측해야 할 것입니다.

455
00:45:13,211 --> 00:45:20,683
Object detection은 Localization과 꽤나 다릅니다.

456
00:45:20,683 --> 00:45:28,870
왜냐하면 Detection 문제에서는 이미지마다 객체의
수가 달라지며, 이를 미리 알 수 없기 때문이죠

457
00:45:28,870 --> 00:45:34,568
따라서 Object Detection 문제로 Regression 문제를
풀기란 상당히 까다로운 문제가 아닐 수 없습니다.

458
00:45:34,568 --> 00:45:40,768
따라서 Object Detection 문제를 풀기 위해서는
색다른 패러다임이 필요합니다.

459
00:45:40,768 --> 00:45:49,958
Object Detection 문제를 풀 때 예전부터 사람들이
많이 시도했던 방법은 sliding window입니다.

460
00:45:49,958 --> 00:45:59,360
앞서 Semantic segmentation에서 작은 영역으로 쪼갰던
아이디어와 비슷한 방법을 사용합니다.

461
00:45:59,360 --> 00:46:05,118
Sliding window를 이용하려면 입력 이미지로부터
다양한 영역을 나눠서 처리합니다.

462
00:46:05,118 --> 00:46:10,359
가령 이미지의 왼쪽 밑에서 작은 영역을 추출해서
그 작은 영역만 CNN의 입력으로 넣습니다.

463
00:46:10,359 --> 00:46:14,829
CNN은 이 작은 영역에 대해서 Classification을
수행할 것입니다.

464
00:46:14,829 --> 00:46:18,160
CNN은 여기에는 개도, 고양이도 없다고 말해줄 것입니다.

465
00:46:18,160 --> 00:46:23,899
단, 여기에서는 카테고리 하나를 추가해야 합니다.
배경(background) 카테고리를 추가합니다.

466
00:46:23,899 --> 00:46:32,288
네트워크가 배경이라고 예측했다면
이 곳은 어떤 카테고리에도 속하지 않는다는 것을 의미합니다.

467
00:46:32,288 --> 00:46:39,008
이미지의 왼쪽 밑 영역에는 아무것도 없으므로
네트워크는 배경이라고 예측할 것이고, 아무것도 없다는 뜻입니다.

468
00:46:39,008 --> 00:46:44,128
그렇다면 다른 영역을 추출해 봅시다. 여기에는
개는 있고, 고양이는 없고, 배경은 아닙니다.

469
00:46:44,128 --> 00:46:47,680
또 다른 영역을 추출해 보겠습니다. 이 곳에는
개는 있고, 고양이는 없고, 배경도 없습니다.

470
00:46:47,680 --> 00:46:54,372
또 다른 영역은 개는 없고 고양이는 있고 배경은 없습니다.
그렇다면 이 방법의 문제는 무엇일까요?

471
00:47:00,324 --> 00:47:04,764
맞습니다. 어떻게 영역을 추출할지가 문제가 될 수 있습니다.
아주 큰 문제입니다.

472
00:47:04,764 --> 00:47:10,543
이미지에 Objects가 몇 개가 존재할지,
어디에 존재할지를 알 수가 없습니다.

473
00:47:10,543 --> 00:47:15,583
그리고 크기가 어떨지도 알 수 없습니다.
그리고 어떤 종횡비로 표현해야 할지도 모릅니다.

474
00:47:15,583 --> 00:47:29,523
따라서 이런 brute force 방식의 sliding window를
하려면 너무나 많은 경우의 수가 존재합니다.

475
00:47:29,523 --> 00:47:37,532
작은 영역 하나 하나마다 거대한 CNN을 통과시키려면
이 때의 계산량은 도무지 다룰 수 조차 없습니다.

476
00:47:37,532 --> 00:47:45,920
Object Detection 문제를 풀려고 brute force
sliding window 를 하는 일은 절대로 없습니다.

477
00:47:47,044 --> 00:47:54,492
대신에  Region Proposals 이라는 방법이 있습니다.
사실 이 방법은 Deep Learning 을 사용하지는 않습니다.

478
00:47:54,492 --> 00:47:56,332
약간은 전통적인 방식이라고 할 수 있습니다.

479
00:47:56,332 --> 00:48:05,401
Region Proposal Network은 전통적인 신호처리
기법을 사용합니다.(faster-rcnn rpn 아님)

480
00:48:05,401 --> 00:48:14,341
Region Proposal Network는 Object가 있을법한
가령, 1000개의 Bbox를 제공해 줍니다.

481
00:48:14,341 --> 00:48:22,382
이미지 내에서 객체가 있을법한 후보 Region
Proposas을 찾아내는 다양한 방법(edges, etc)이 있겠지만.

482
00:48:22,382 --> 00:48:30,132
Region Proposal Network는
이미지 내에 뭉텅진(blobby) 곳들을 찾아냅니다.

483
00:48:30,132 --> 00:48:38,962
이 지역들은 객체가 있을지도 모르는 후보 영역들입니다.
이런 알고리즘은은 비교적 빠르게 동작합니다.

484
00:48:38,962 --> 00:48:44,703
Region Proposal을 만들어낼 수 있는 방법에는
Selective Search가 있습니다.

485
00:48:44,703 --> 00:48:49,284
 Selective Search은 슬라이드에 적힌 1000개가 아니라
2000개의 Region Proposal을 만들어 냅니다.

486
00:48:49,284 --> 00:48:59,404
CPU로 2초간 Selective Search를 돌리면 객체가 있을만한
2000개의 Region Proposal을 만들어냅니다.

487
00:48:59,404 --> 00:49:05,052
이 방법은 노이즈가 아주 심합니다. 대부분은
실제 객체가 아니겠지만 Recall 은 아주 높습니다.

488
00:49:05,052 --> 00:49:11,204
따라서 이미지에 객체가 존재한다면 Selective Search
의 Region Proposal 안에 속할 가능성이 높습니다.

489
00:49:11,204 --> 00:49:17,103
자 이제는 무식하게 이미지 내의 모든 위치와
스케일을 전부 고려하는 것이 아니라

490
00:49:17,103 --> 00:49:25,164
우선 Region Proposal Networks를 적용하고
객체가 있을법한 Region Proposal 을 얻어냅니다.

491
00:49:25,164 --> 00:49:33,135
그리고 이 Region Proposals을 CNN의 입력으로 하는 것이죠.
이 방법을 사용하면 계산량을 다루기 훨씬 수월합니다.

492
00:49:33,135 --> 00:49:36,903
모든 위치와 스케일을 전부 고려하는 (brute force)
방법보다는 낫습니다.

493
00:49:36,903 --> 00:49:45,583
지금까지 말씀드린 아이디어가 모두 몇해 전 나온
R-CNN이라는 논문에 등장합니다.

494
00:49:45,583 --> 00:49:53,263
이미지가 주어지면  Region Proposal을 얻기 위해
Region Proposal Network를 수행합니다.

495
00:49:53,263 --> 00:49:56,724
 Region Proposal은 Region of Interest (ROI)
라고도 합니다. Selective Search를 통해

496
00:49:56,724 --> 00:49:59,692
2000개의 ROI를 얻어냅니다.

497
00:49:59,692 --> 00:50:07,043
하지만 여기에서는 각 ROI의 사이즈가
각양각색이라는 점이 문제가 될 수 있습니다.

498
00:50:07,043 --> 00:50:13,143
추출된 ROI로 CNN Classification을 수행하려면

499
00:50:13,143 --> 00:50:18,149
FC-Layer 등으로 인해서 보통 같은
입력사이즈로 맞춰줘야만 합니다.

500
00:50:18,149 --> 00:50:26,855
따라서 Region proposals을 추출하면 CNN의 입력으로
사용하기 위해서는 동일한 고정된 크기로 변형시켜야 합니다.

501
00:50:26,855 --> 00:50:34,090
다시말해 Region proposals을 추출하면
고정된 사이즈로 크기를 바꿉니다.

502
00:50:34,090 --> 00:50:37,418
그리고 각각의 Region Proposals을
CNN에 통과시킵니다.

503
00:50:37,418 --> 00:50:48,479
그리고 RCNN의 경우에는 ROI들의
최종 Classification에 SVM을 사용했습니다.

504
00:50:48,479 --> 00:50:52,506
슬라이드가 사라졌네요 :(

505
00:50:52,506 --> 00:51:05,650
지금 슬라이드에는 없지만 RCNN은 Region Proposals을
보정하기 위한 regression 과정도 거칩니다.

506
00:51:05,650 --> 00:51:13,549
Selective Search의 Region Proposals이 대게는
정확하지만 그렇지 못한 경우도 있기 때문입니다.

507
00:51:13,549 --> 00:51:24,658
RCNN은 BBox의 카테고리도 예측하지만, BBox를 보정해줄
수 있는 offset 값 4 개도 예측합니다.

508
00:51:24,658 --> 00:51:27,919
이를 Multi-task loss로 두고 한번에 학습합니다.

509
00:51:27,919 --> 00:51:30,169
질문있나요?

510
00:51:35,511 --> 00:51:39,359
"종횡비(aspect ratio)가 변함에 따라 정확도에
얼마나 영햐을 미치는지" 입니다.

511
00:51:40,698 --> 00:51:41,772
말씀드리기 힘들 것 같습니다.

512
00:51:41,772 --> 00:51:46,551
제 생각에는 논문에 이와 관련된 대조실험 (controlled
experiments)이 있을 것 같은데 확실치 않습니다.

513
00:51:46,551 --> 00:51:48,738
확답을 드릴 수는 없을 것 같습니다.

514
00:51:48,738 --> 00:51:49,571
질문있나요?

515
00:51:53,602 --> 00:51:56,772
질문은 "ROI가 굳이 사각형이어야 할 이유가
있는지" 입니다.

516
00:51:56,772 --> 00:52:03,731
대게 사격형을 씁니다. 사각형이 아닌 것들 (non-region things)
의 크기를 조정하기(warp)는 까다롭습니다.

517
00:52:03,731 --> 00:52:08,911
Instatnt Segmantation 의 경우에는
Proposals이 사각형이 아닌 경우도 있습니다.

518
00:52:08,911 --> 00:52:12,071
이 경우에는 사각형이 아닌 것들을
예측해야 하기도 합니다.

519
00:52:12,071 --> 00:52:14,238
질문 있나요?

520
00:52:18,704 --> 00:52:24,375
질문은 "Region Proposals"이 학습되는 것인지 입니다.
R-CNN의 Region Proposals은 전통적인 방식을 사용합니다.

521
00:52:24,375 --> 00:52:29,203
RCNN에서 Region Proposal을 학습시키지는 않습니다.
고정된 알고리즘을 씁니다.(Selective Search)

522
00:52:29,203 --> 00:52:33,466
하지만 잠시후에 배우게될 알고리즘들 에서는
양상이 조금 바뀝니다.

523
00:52:33,466 --> 00:52:35,633
다른 질문 있나요?

524
00:52:37,767 --> 00:52:40,735
질문은 offsets이 항상 ROI의
안쪽으로만 작용할 수 있는지 입니다.

525
00:52:40,735 --> 00:52:42,665
대답은 "아니요" 입니다. 그래서는 안됍니다.

526
00:52:42,665 --> 00:52:50,786
가령 현재 Region proposals이 사람을 잡았는데
머리를 빼먹었다고 생각해봅시다. 네트워크는

527
00:52:50,786 --> 00:52:55,906
"오 이건 사람이야. 근데 머리가 없네. 사람은 머리가 있어야 해"
라고 추론하면서 Bbox를 조금 더 위로 올릴 수도 있어야겠죠

528
00:52:55,906 --> 00:52:59,666
따라서 예측한 BBox의 offset이 BBox의
외부로 향하기도 합니다.

529
00:52:59,666 --> 00:53:00,499
질문있나요?

530
00:53:08,110 --> 00:53:12,801
질문은 "수 많은 ROIs 중에서 실제 객체를
포함하지 않은 ROIs는 어떻게 해야 하는지" 입니다.

531
00:53:15,877 --> 00:53:22,550
앞서 말씀드렸습니다만 카테고리에 배경(Background)
클래스를 추가시킵니다.

532
00:53:22,550 --> 00:53:26,289
네트워크는 객체가 없는 ROI는 배경이라고 예측합니다.

533
00:53:26,289 --> 00:53:27,122
질문있나요?

534
00:53:37,716 --> 00:53:40,894
질문은 "필요한 데이터가 무엇인지" 입니다.

535
00:53:40,894 --> 00:53:53,383
이 Task는 Fully Supervised 입니다. 따라서 학습데이터에는
이미지 내의 모든 객체에 대한 BBox가 있어야 합니다.

536
00:53:53,383 --> 00:54:02,945
학습데이터에 BBox Ground Truth가 일부만 혹은 아얘 없거나
노이즈가 심한 경우 어떻게 학습할지에 대한 논문들도 있습니다.

537
00:54:02,945 --> 00:54:08,568
하지만 일반적인 상황에서는 Train time에
Fully supervision이 있다고 가정합니다.

538
00:54:09,835 --> 00:54:16,535
여러분들도 느꼈겠지만 R-CNN 프레임워크에는
많은 문제점들이 있습니다.

539
00:54:16,535 --> 00:54:21,644
참고로, 오른쪽 그림에 보시면 Bbox reg가 보이는군요.
(앞서 슬라이드가 없어졌었음)

540
00:54:21,644 --> 00:54:25,811
R-CNN은 여전히 계산비용이 높습니다.

541
00:54:27,436 --> 00:54:34,415
R-CNN은 2000개의 Region proposals이 있고 각각이
독립적으로 CNN입력으로 들어갑니다.

542
00:54:34,415 --> 00:54:42,895
그리고 학습이 되지 않은 이 Region Proposal은
앞으로 문제가 될 소지가 많습니다.

543
00:54:42,895 --> 00:54:46,015
그리고 R-CNN은 학습과정 자체가 상당히 오래걸립니다.

544
00:54:46,015 --> 00:54:54,721
R-CNN의 (original) 구현을 살펴보자면 CNN에서 나온
Feature를 디스크에 덤핑시킵니다. 용량이 어마어마합니다.

545
00:54:54,721 --> 00:54:58,472
학습 과정도 상당히 느립니다. 이미지당 2000개의
ROIs를 forward/backwrad pass를 수행하겠죠

546
00:54:58,472 --> 00:55:06,134
논문에 써있기를 전체 학습시간이 81시간이 소요됐다고 합니다.
아주 느립니다.

547
00:55:06,134 --> 00:55:11,076
Test time도 아주 느립니다.
이미지 한 장당 대략 30초가 걸립니다.

548
00:55:11,076 --> 00:55:18,316
각 Region proposals 마다 CNN을 수행해야 하므로 수천 번의
forward passes가 요구됩니다. 아주 느린 과정입니다.

549
00:55:18,316 --> 00:55:27,404
고맙게도 :) Fast R-CNN은 문제들을 상당부분 해결하였습니다.
Fast R-CNN도 R-CNN과 시작은 같습니다.

550
00:55:27,404 --> 00:55:34,116
하지만 Fast R-CNN에서는 각 ROI마다 각각 CNN을
수행하지 않습니다. 전체 이미지에 CNN을 수행하죠

551
00:55:34,116 --> 00:55:41,924
그 결과 전체 이미지에 대한 고해상도
Feature Map을 얻을 수 있습니다.

552
00:55:41,924 --> 00:55:46,652
Fast R-CNN에는 여전히 Selective Search같은 방법으로
Region proposals을 계산합니다.

553
00:55:46,652 --> 00:55:52,334
자 이제부터는 이미지에서 ROI를
뜯어내지 않습니다.

554
00:55:52,334 --> 00:56:04,745
이제부터는 CNN Feature map에 ROI를 Projection 시키고
전체 이미지가 아닌 Feature map에서 뜯어옵니다.

555
00:56:04,745 --> 00:56:13,425
이제는 CNN의 Feature를 여러 ROIs가
서로 공유할 수 있습니다.

556
00:56:13,425 --> 00:56:20,052
그 다음 FC-layer이 있습니다. FC-Layer는
고정된 크기의 입력을 받습니다.

557
00:56:20,052 --> 00:56:26,131
따라서 CNN Feature Map에서 뜯어온 ROI는
FC-Layer의 입력에 알맞게 크기를 조정해 줘야 합니다.

558
00:56:26,131 --> 00:56:31,673
학습이 가능하도록 미분가능한 방법을 사용해야겠죠.
이 방법이 바로 ROI pooling layer 입니다.

559
00:56:31,673 --> 00:56:38,622
Feature Map에서 뜯어낸 ROI의 크기를
조정하고(warped)나면

560
00:56:38,622 --> 00:56:45,673
FC-Layer의 입력으로 넣어서 Classification Score와
 Linear Regression Offset을 계산할 수 있습니다.

561
00:56:45,673 --> 00:56:51,654
Fast R-CNN을 학습할 때는 두 Loss를 합쳐
Multi-task Loss로 Backprop를 진행합니다.

562
00:56:51,654 --> 00:56:56,124
이 방법을 통해 전체 네트워크를
합쳐서(jointly) 동시에 학습시킬 수 있습니다.

563
00:56:56,124 --> 00:57:03,575
ROI pooling은 max pooling과 유사하나
자세히 다루지는 않겠습니다.

564
00:57:03,575 --> 00:57:12,014
R-CNN과 Fast R-CNN을 비교해 보도록 하겠습니다.
SPP net이라는 다른 네트워크도 있습니다.

565
00:57:12,014 --> 00:57:16,924
Train time 에는 fast R-CNN이 10배 가량 더 빠릅니다.

566
00:57:16,924 --> 00:57:20,134
Faster R-CNN은 Feature map을 서로 공유하기 때문입니다.

567
00:57:20,134 --> 00:57:23,272
Test time에는 fast R-CNN은 정말 빠릅니다.

568
00:57:23,272 --> 00:57:33,764
Fast R-CNN은 정말 빠르기 때문에
Region Proposal을 계산하는 시간이 대부분이게 됩니다.

569
00:57:33,764 --> 00:57:39,334
2000개의 Region Proposal을 Selective Search로
계산하는데 2초 가량 걸립니다.

570
00:57:39,334 --> 00:57:53,273
Region Proposals을 계산한 이후 CNN 을 거치는 과정은
모든 Region Proposals이 공유하기 때문에 1초도 안걸립니다.

571
00:57:53,273 --> 00:57:59,142
따라서 fast R-CNN은 Region Proposal을
계산하는 구간이 병목입니다.

572
00:57:59,142 --> 00:58:03,804
 고맙게도 faster R-CNN이 이 문제를 해결해줍니다.

573
00:58:03,804 --> 00:58:13,734
지금까지의 문제는 region proposals을 계산하는
과정이 병목이라는 점이었습니다.

574
00:58:13,734 --> 00:58:18,054
Faster R-CNN은 네트워크가 region proposal 을
직접 만들 수 있습니다.

575
00:58:18,054 --> 00:58:30,572
입력 이미지가 있습니다. 그리고 입력 이미지 전체가 네트워크로
들어가서 Feature map 을 만듭니다.

576
00:58:30,572 --> 00:58:33,204
Faster R-CNN은 별도의
Region proposal network가 있습니다.

577
00:58:33,204 --> 00:58:39,204
RPN은 네트워크가 Feature Map을 가지고
Region proposals을 계산하도록 합니다.

578
00:58:39,204 --> 00:58:44,542
RPN을 거쳐 Region Proposal을 예측하고나면
나머지 동작은 fast R-CNN과 동일합니다.

579
00:58:44,542 --> 00:58:50,662
Conv Feature map에서 Region proposals을
뜯어내고 이들을 나머지 네트워크에 통과시킵니다.

580
00:58:50,662 --> 00:58:57,094
그리고 multl-task loss를 이용해서 여러가지
Losses를 한번에 계산합니다.

581
00:58:57,094 --> 00:59:05,019
Faster R-CNN은 4개의 Losses를 한번에 학습합니다.
이 Loss들의 균형을 맞추는 것은 사실 조금 까다롭습니다.

582
00:59:05,019 --> 00:59:14,848
RPN에는 2가지 Losses가 있습니다. 우선 한가지는
이곳에 객체가 있는지 없는지를 예측합니다.

583
00:59:14,848 --> 00:59:18,186
그리고 나머지 Loss는 예측한 BBox에 관한 것이죠

584
00:59:18,186 --> 00:59:21,787
그리고 Faster R-CNN의 최종단 에서도
두 개의 Losses가 있습니다.

585
00:59:21,787 --> 00:59:26,288
하나는 Region Proposals의
Classification 을 결정합니다.

586
00:59:26,288 --> 00:59:34,086
그리고 남은 하나는 BBox Regression 입니다.
앞서 만든 Region Proposal을 보정해주는 역할입니다.

587
00:59:34,086 --> 00:59:34,919
질문 있나요?

588
00:59:45,231 --> 00:59:50,703
질문은 "Multi-task Learning이 얼핏 보면
Regularization 처럼 보이는데, 그런 효과가 있는지" 입니다.

589
00:59:50,703 --> 00:59:52,602
그런 식의 controlled studies이 있었는지 잘 모르겠습니다.

590
00:59:52,602 --> 01:00:01,162
그렇긴 하지만, Original Faster R-CNN 논문을 보면
몇 가지 실험을 진행합니다.

591
01:00:01,162 --> 01:00:03,951
region proposal network의 두가지 Loss를 합쳐서
학습하거나 나눠서 학습하면 성능이 어떻게 달라지는지

592
01:00:03,951 --> 01:00:08,522
RPN과 Classification Network를 분리하면
성능이 어떻게 변하는지 실험해봅니다.

593
01:00:08,522 --> 01:00:12,970
이들 사이에 조금의 변화는 있겠지만
엄청 큰 차이점은 없습니다.

594
01:00:12,970 --> 01:00:18,380
하지만 실제로는 통짜로 학습합니다.
계산량이 가장 적기 떄문입니다.

595
01:00:18,380 --> 01:00:19,713
질문있나요?

596
01:00:33,583 --> 01:00:41,903
질문은 "어떻게 Region proposal network GT가 없는데
어떻게 RPN을 학습시키는지 입니다."

597
01:00:41,903 --> 01:00:45,172
이 부분에 대해서 자세하게 설명해 드리진 않겠습니다.

598
01:00:45,172 --> 01:00:53,452
간단하게 설명해드리면 ground truth objects와
일정 threshold이상 겹치는 proposals이 있을 것입니다.

599
01:00:53,452 --> 01:00:57,771
이런 region proposal은 positive라고 예측해야 합니다.

600
01:00:57,771 --> 01:01:04,471
반면 GT objects와 조금만 겹치는 proposals은
negative라고 예측해야 합니다.

601
01:01:04,471 --> 01:01:09,550
하지만 여기에는 흑마법 스러운 하이퍼파라미터가
많기 때문에 자세한 설명은 생략하겠습니다.

602
01:01:09,550 --> 01:01:10,383
질문있나요?

603
01:01:15,394 --> 01:01:19,793
질문은 "Region proposal network의
classification loss가 무엇인지" 입니다.

604
01:01:19,793 --> 01:01:26,648
간단히 말씀드리면 RPN은
Binary Classification을 수행합니다.

605
01:01:26,648 --> 01:01:32,269
RPN은 Region proposal 후보들에 대해서
각각을 binary decision 합니다.

606
01:01:32,269 --> 01:01:34,078
Region 안에 객체가 존재하는지 아닌지를 결정하는 것이죠

607
01:01:34,078 --> 01:01:37,578
따라서 Loss는 Binary Classification Loss 입니다.

608
01:01:38,520 --> 01:01:43,658
Faster R-CNN은
정말로 엄청 빠릅니다.

609
01:01:43,658 --> 01:01:48,706
빨라진 가장 큰 이유는 네트워크 밖에서 계산했던
Region proposals의 병목을 제거했기 때문입니다.

610
01:01:48,706 --> 01:01:53,588
이로 인해 다른 네트워크들 보다
훨씬 더 빨라지게 되었습니다.

611
01:01:53,588 --> 01:01:59,388
Faster R-CNN에서 흥미로운 점은
Region proposals 자체도 학습되었기 때문에

612
01:01:59,388 --> 01:02:05,086
RPN과 우리의 새로운 데이터 사이의
간극이 존재할 수도 있을 것입니다.

613
01:02:05,086 --> 01:02:16,320
이 경우에는 새로운 데이터에 맞게
region proposal을 새롭게 학습시키면 됩니다.

614
01:02:16,320 --> 01:02:22,914
지금까지 살펴본 R-CNN 패밀리들이 있습니다.
R은 " Region" 을 뜻합니다.

615
01:02:22,914 --> 01:02:30,716
R-CNN 계열 네트워크들은 후보 ROIs 마다
독립적으로 연산을 수행합니다. (FC-layer)

616
01:02:30,716 --> 01:02:36,708
R-CNN 계열의 네트워크들을
region-based method 라고 합니다.

617
01:02:36,708 --> 01:02:40,676
 object detection에는 다른 방법도 있습니다.

618
01:02:40,676 --> 01:02:43,818
Feed forward를 오로지 한 방향으로 수행하는 네트워크들이죠

619
01:02:43,818 --> 01:02:48,076
그중 하나가 YOLO입니다.
You Only Look Once라는 뜻이죠

620
01:02:48,076 --> 01:02:50,796
다른 하나는 SSD 입니다.
Single Shot Detection이란 뜻입니다.

621
01:02:50,796 --> 01:02:54,067
YOLO와 SSD는 거의 같은 시기에 나왔습니다.

622
01:02:54,067 --> 01:03:02,348
이들의 주요 아이디어는 각 Task를 따로 계산하지
말고 하나의 regression 문제로 풀어보자는 것입니다.

623
01:03:02,348 --> 01:03:06,156
거대한 CNN을 통과하면
모든 것을 담은 예측값이 한번에 나옵니다.

624
01:03:06,156 --> 01:03:13,468
입력 이미지가 있으면 이미지를
큼지막하게 나눕니다. 가령 7x7 grid로 나눌 수 있을 것입니다.

625
01:03:13,468 --> 01:03:18,556
각 Grid Cell 내부에는
Base BBox가 존재합니다.

626
01:03:18,556 --> 01:03:25,748
이 경우에는 Base BBox가 세 가지 있습니다. 길쭉한놈
넓죽한놈 정사각형 이죠 실제로는 세 개 이상 사용합니다.

627
01:03:25,748 --> 01:03:32,858
이제는 이 객 grid cell에 대해서 BBoxes가 있고
이를 기반으로 예측을 수행할 것입니다.

628
01:03:32,858 --> 01:03:41,868
우선 하나는 BBox의 offset을 예측할 수 있을 것입니다.
실제 위치가 되려면 base BBox를 얼만큼 옮겨야 하는지를 뜻합니다.

629
01:03:43,020 --> 01:03:51,460
그리고 각 BBox에 대해서
Classification scores를 계산해야 합니다.

630
01:03:51,460 --> 01:03:55,503
이 BBox 안에 이 카테고리에 속한 객체가
존재할 가능성을 의미합니다.

631
01:03:55,503 --> 01:04:03,929
네트워크에 입력 이미지가 들어오면
7 x 7  Grid마다 (5B + C) 개의 tensor를 가집니다.

632
01:04:04,951 --> 01:04:12,700
여기에서 B는 base BBox의 offset (4개)과
confidence score(1개)로 구성됩니다.

633
01:04:12,700 --> 01:04:16,340
그리고 C는 C개의 카테고리에 대한
Classification score 입니다.

634
01:04:16,340 --> 01:04:23,522
정리하면, 네트워크이 입력은 이미지이고
출력은 3-dim tensor 입니다.

635
01:04:23,522 --> 01:04:27,722
그리고 이를 거대한 CNN으로
한번에 학습시킵니다.

636
01:04:27,722 --> 01:04:30,682
지금까지 알아본 방법들(YOLO/SDD)은
"Single Shot Mthods" 입니다.

637
01:04:30,682 --> 01:04:41,180
후보 base BBoxes와 GT Objects를 매칭시키는 방법입니다.

638
01:04:41,180 --> 01:04:48,539
하지만 가만보면 Faster R-CNN에서 쓰는
 RPN이 이와 유사해 보입니다.

639
01:04:48,539 --> 01:04:55,279
결국은 둘 다
 Regression + Classification 문제를 푸는 것입니다.

640
01:04:55,279 --> 01:04:59,196
R-CNN 계열, Single-Shot 계열 이라고 나눠도
분명 겹치는 아이디어들이 있습니다.

641
01:05:00,388 --> 01:05:13,892
Faster R-CNN은 RPN으로 먼저 Regression 문제를 풀고
ROI단위로 Classification을 하는 방식입니다.

642
01:05:13,892 --> 01:05:19,761
반면 single shot methods는
단 한번에 forward pass만으로 끝내버립니다.

643
01:05:19,761 --> 01:05:21,740
object detection 문제에는
아주 다양한 요소들이 있습니다.

644
01:05:21,740 --> 01:05:23,950
가령 다양한 base networks들을 적용해 볼 수도
있습니다. VGG, ResNet 등 말이죠

645
01:05:23,950 --> 01:05:29,601
그리고 다양한 아키텍쳐를 선택할 수 있습니다.
여러 대분류(metastrategies)가 있었습니다.

646
01:05:29,601 --> 01:05:31,820
가령 Faster R-CNN과 같은
Region을 기반으로한 방법들도 있었고

647
01:05:31,820 --> 01:05:34,060
Sigle Shot Detection 기반의 방법들도 있었습니다.

648
01:05:34,060 --> 01:05:38,153
제가 말씀드리지 않았지만 R-FCN 도 있습니다.
앞서 말씀드린 두 집단의 중간 위치에 있습니다.

649
01:05:38,153 --> 01:05:39,580
그리고 아주 다양한 Hyperparameters가 있습니다.

650
01:05:39,580 --> 01:05:43,590
이미지 크기를 몇 으로 할지,
Region Proposals을 몇 개로 할 지 아주 다양합니다.

651
01:05:43,590 --> 01:05:48,022
올해(2017) CVPR에 실린 아주 좋은 논문이 있습니다.

652
01:05:48,022 --> 01:05:56,353
앞서 말씀드린 다양한 알고리즘들의 성능을 측정하기 위해
다양한 변수들을 이용해서 통제실험을 진행한 논문입니다.

653
01:05:56,353 --> 01:05:58,676
관심있으신 분들은 이 논문을 보시기 바랍니다.

654
01:05:58,676 --> 01:06:06,702
이 논문의 키 포인트중 하나는 Faster R-CNN 계열의
Region based methods는 정확도가 높긴 하나

655
01:06:06,702 --> 01:06:08,972
single shot methods보다는 속도가 느리다는 것입니다.

656
01:06:08,972 --> 01:06:12,486
Single shot methods는 ROI당 별도의
연산을 요구하지 않기 떄문입니다.

657
01:06:12,486 --> 01:06:17,204
자세한 내용은 논문을 참고하시기 바랍니다.

658
01:06:17,204 --> 01:06:24,621
몇 해 전, Andrej와 저는 Object Detection과
Image Cationing을 조합한 재미있는 논문을 발표했습니다.

659
01:06:24,621 --> 01:06:27,273
이 문제를 dense captioning 라고 합니다.

660
01:06:27,273 --> 01:06:32,472
이 문제에서는 각 Region에 대해서 카테고리를
예측하는 것이 아니라

661
01:06:32,472 --> 01:06:35,084
각 Region의 Caption을 예측해야 합니다.

662
01:06:35,084 --> 01:06:41,033
이 문제를 위해서는 각 Region에 Caption이 있는
데이터셋이 있어야 합니다.

663
01:06:41,033 --> 01:06:46,153
우리는 이 모델을 End-to-end로 학습시켜서
이 모든 걸을 동시에 예측할 수 있도록 만들었습니다.

664
01:06:46,153 --> 01:06:50,962
이 네트워크는  Faster R-CNN과 방식이 유사합니다.
네트워크에는 Region proposal stage가 있습니다.

665
01:06:50,962 --> 01:06:53,764
그리고 예측한 BBox 단위로 추가적인 처리를 합니다.

666
01:06:53,764 --> 01:07:03,454
Caption을 예측해야 하므로 SVM이나 Softmax loss
를 쓰지 않고 RNN Language Model을 도입했습니다.

667
01:07:03,454 --> 01:07:06,814
전체적인 모습은 Faster R-CNN 스럽게 생겼습니다.

668
01:07:06,814 --> 01:07:11,524
비디오 자료가 있지만 시간 관계 상 생략 하겠습니다.

669
01:07:11,524 --> 01:07:17,897
제가 이걸 보여드린 이유는. 다양한 문제들을
서로 묶어서 문제를 풀 수 있다는 것을 보여드리기 위해서입니다.

670
01:07:17,897 --> 01:07:21,508
가령 Dense Captioning과 같은 새로운 문제가 있을 떄

671
01:07:21,508 --> 01:07:26,860
우리가 앞서 이미 다룬 Object Detection 이나
Image Captioning의 요소들을 재활용할 수 있다는 뜻입니다.

672
01:07:26,860 --> 01:07:32,565
두 네트워크를 합쳐서 end-to-end로 학습시킴으로써
여러분의 문제를 해결해 볼 수 있을 것입니다.

673
01:07:32,565 --> 01:07:36,567
오늘 배울 마지막 Task는
Instance Segmentation 입니다.

674
01:07:36,567 --> 01:07:40,636
 instance segmentation는 지금까지 배운 것들의
종합 선물 세트입니다.

675
01:07:40,636 --> 01:07:50,594
입력 이미지가 주어지면 객체 별로 객체의
위치를 알아내야 합니다. Object Detection 문제와 유사합니다.

676
01:07:50,594 --> 01:07:55,385
하지만 객체별로 BBox를 예측하는 것이 아니라
객체 별 Segmentation Mask를 예측해야 합니다.

677
01:07:55,385 --> 01:08:02,785
이미지에서 각 객체에 해당하는 픽셀을
예측해야 하는 문제입니다.

678
01:08:02,785 --> 01:08:07,484
Instance Segmentation은 Semantic
Segmentation과 Object Detection을 짬뽕한 것입니다.

679
01:08:07,484 --> 01:08:15,196
Object Detection 문제 처럼 객체별로
여러 객체를 찾고 각각을 구분해 줘야 합니다.

680
01:08:15,196 --> 01:08:21,924
가령 이미지 내에 두 마리의 개가 있으면
Instance segmentation은 이 두 마리를 구별해야 합니다.

681
01:08:21,924 --> 01:08:32,765
그리고 각 픽셀이 어떤 객체에 속하는지를
전부 다 결정해 줘야 합니다.

682
01:08:32,765 --> 01:08:38,247
Instance Segmentation 문제를 푸는
아주 다양한 방법이 있습니다만

683
01:08:38,247 --> 01:08:49,868
지난 달에 아카이브에 올라온 아주 따끈따끈한 SOTA
Mask R-CNN 이라는 논문이 있습니다.

684
01:08:49,868 --> 01:08:52,675
Mask R-CNN은 faster R-CNN과 유사합니다.

685
01:08:52,676 --> 01:08:55,296
Mask R-CNN은 여러 스테이지를 거칩니다.

686
01:08:55,296 --> 01:09:05,622
Mask R-CNN은 처음 입력 이미지가 CNN과 RPN을 거칩니다.
여기까지는 Faster R-CNN과 유사합니다.

687
01:09:05,622 --> 01:09:14,795
그리고 Fast/Faster R-CNN에서 했던 것 처럼 특징 맵에서
RPN의 ROI만큼을 뜯어냅(project)니다.

688
01:09:14,796 --> 01:09:21,228
그 다음 단계는 Faster R-CNN에서 처럼 Classification/
BBox Regression을 하는 것이 아니라

689
01:09:21,229 --> 01:09:27,478
각 BBox마다 Segmentation mask를 예측하도록 합니다.

690
01:09:27,478 --> 01:09:36,888
RPN으로 뽑은 ROI 영역 내에서 각각
semantic segmentation을 수행합니다.

691
01:09:36,889 --> 01:09:45,947
Feature Map으로부터 ROI Pooling(Align)을 수행하면
두 갈래로 나눱니다.

692
01:09:45,948 --> 01:09:53,750
상단에 보이는 첫 번째 갈래는
Faster R-CNN과 유사하게 생겼습니다.

693
01:09:53,750 --> 01:09:59,318
첫 번째 갈래에서는 각 Region proposal이
어떤 카테고리에 속하는지 계산합니다.

694
01:09:59,318 --> 01:10:04,596
그리고 Region Proposal의 좌표를 보정해주는
BBox Regression도 예측합니다.

695
01:10:04,596 --> 01:10:13,550
그리고 하단의 두 번째 갈래는 Semantic Segmentation을 위한
미니 네트워크같이 생겼습니다.

696
01:10:13,550 --> 01:10:17,780
각 픽셀마다 객체인지 아닌지를 분류합니다.

697
01:10:17,780 --> 01:10:29,230
Mask R-CNN은 오늘 배운 모든 방법들을
전부 통합시켰다고 볼 수 있습니다.

698
01:10:29,230 --> 01:10:36,710
엄청 멋있는 방법이면서도 아주 잘 동작합니다.
논문의 예시를 보면 아주 놀랍습니다.

699
01:10:36,710 --> 01:10:39,078
Ground Truth와도 구별의 거의 불가능할 정도입니다.

700
01:10:39,078 --> 01:10:49,497
왼쪽의 예시는 보면 두 사람이 오토바이 뒤에 서 있습니다.
이 사람들에 BBox와 Segmentation를 볼 수 있습니다.

701
01:10:49,497 --> 01:10:54,961
왼쪽 사진을 잘 보시면 배경 먼 발치에
군중들이 보이실 것입니다.

702
01:10:54,961 --> 01:10:58,628
이 작은 군중들에도 BBox와 Segmentation이
아주 잘 수행된 것을 보실 수 있습니다.

703
01:10:58,628 --> 01:11:08,028
Mask R-CNN은 성능이 아주 뛰어나면서도
Faster R-CNN 프레임워크 기반으로 비교적 쉽게 구현할 수 있습니다.

704
01:11:08,028 --> 01:11:15,108
Mask R-CNN이 오늘 배운 모든 방법을 통합시켰다고 말씀드렸습니다.
그런데 Mask-RCNN으로는 Pose estimation도 가능합니다.

705
01:11:15,108 --> 01:11:22,257
사람들의 관절의 좌표를 예측하는 부분을 추가해서
Pose estimation도 수행할 수 있습니다.

706
01:11:22,257 --> 01:11:29,388
Mask-RCNN 하나로 Object Detection,  Pose
estimation, Instance segmentation이 가능합니다.

707
01:11:29,388 --> 01:11:35,246
Pose estimation을 위해서는 각 Region proposals
갈래 하나를 추가해서

708
01:11:35,246 --> 01:11:42,628
현재 Region proposal 안의 객체의 관절대
해당하는 좌표를 예측하도록 하면 됩니다.

709
01:11:42,628 --> 01:11:51,715
이를 위해서는 Loss와 Layer를 하나 더 추가하면 됩니다.
Multi-task Loss에 Loss가 하나 더 추가되는 것입니다.

710
01:11:51,715 --> 01:11:59,406
이렇게 갈래를 하나 추가시키고는 한번에 학 습시킵니다.
그러면 이와 같은 결과를 얻을 수 있습니다.

711
01:11:59,406 --> 01:12:02,705
Mask R-CNN은 Feedforward 한 번으로

712
01:12:02,705 --> 01:12:09,792
이미지 내에 사람이 몇 명 있는지, 어디에 있는지,
어떤 픽셀에 해당하는지를 알아낼 수 있고, 뿐만 아니라

713
01:12:09,792 --> 01:12:22,742
사람들의 Skeleton Estimation도 가능합니다. 심지어 사람들이
아주 많이 겹쳐있는 교실 이미지에서도 정말 잘됩니다.

714
01:12:22,742 --> 01:12:28,291
그리고 Faster R-CNN 프레임워크 기반이기 때문에
실시간에 가깝게 처리할 수 있습니다.

715
01:12:28,291 --> 01:12:36,061
이 모든 것이 Forward pass 한 번으로 수행되므로
GPU에서 1초에 5장 정도 처리할 수 있습니다.

716
01:12:36,061 --> 01:12:42,833
Mask R-CNN논문은 아주 최근에 나온 논문입니다.
몇 달내로 아주 핫한 논문이 될 것입니다.

717
01:12:42,833 --> 01:12:45,430
정리해 보면 ...

718
01:12:45,430 --> 01:12:46,680
질문있나요?

719
01:12:53,800 --> 01:12:55,781
질문은 "데이터가 얼마나 많이 필요한지" 입니다.

720
01:12:55,781 --> 01:13:00,948
이 Instant Segmentation은 MS Coco
데이터 셋으로 학습시킨 결과입니다.

721
01:13:00,948 --> 01:13:08,320
MS Coco가 아마도 200,000여 개 정도 될 것입니다.
MS Coco에서는 80개의 카테고리를 다룹니다.

722
01:13:08,320 --> 01:13:14,010
200,000 개의 학습 이미지들 안의 모든 객체들에는
80개의 카테고리에 속하는 label을 가지고 있습니다.

723
01:13:14,010 --> 01:13:23,285
200,000 개 이미지 안에는 평균 5~6 개의 객체가 있습니다.
아주 큰 데이터셋 입니다.

724
01:13:23,285 --> 01:13:32,000
그리고 MS Coco 데이터셋 이미지에 있는 모든 사람 객체들의
관절에는 그 위치가 표시되어 있습니다.

725
01:13:32,000 --> 01:13:36,669
Mask R-CNN도 Coco로 학습시켰기 때문에
아주 많은 데이터로 학습시켰다고 볼 수 있습니다.

726
01:13:36,669 --> 01:13:42,050
여기에는 앞으로 연구가 아주 활발하게 진행될 주제가 있습니다.

727
01:13:42,050 --> 01:13:50,701
지금까지는 엄청나게 많은 데이터를 가지고
다양한 Tasks를 아주 잘 해결할 수 있었습니다.

728
01:13:50,701 --> 01:13:59,069
하지만 더 적은 학습 데이터로 좋은 성능을 내는 법은
앞으로도 아주 활발해게 연구될 분야입니다.

729
01:13:59,069 --> 01:14:03,301
향 후 몇 년간 아주 많은 연구가 있을 것입니다.

730
01:14:03,301 --> 01:14:08,068
오늘 한 내용을 살펴보자면, 여러가지 Computer
Vision Tasks를 정신없이 배워보았습니다.

731
01:14:08,068 --> 01:14:15,925
그리고 Image Classification의 방법론들을
다른 Task에서 어떻게 활용할 수 있는지 배웠습니다.

732
01:14:15,925 --> 01:14:22,835
다음 시간에는 CNN features의 시각화,  Deep Dream,
Style Transfer를 배우겠습니다. 아주 재밌을 것입니다.

